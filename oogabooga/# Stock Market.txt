# Stock Market



    async def check_market(self, ctx):
#        if self.market_breaker != True:
#            return
        etf_id = 6
        etf_value = await get_etf_value(self, ctx, etf_id)

        if self.last_market_value != 0:
            percentage_change = ((etf_value - self.last_market_value) / self.last_market_value) * 100
            print(f"Market Monitor: {percentage_change}%")

            if self.market_circuit_breaker == True:
                if abs(percentage_change) >= self.market_limit:
                    # Halt trading for 30 minutes
                    self.is_halted = True
                    embed = discord.Embed(description=f"Trading Halted due to a significant market change. Waiting for {(self.market_timeout / 60)} minutes.", color=discord.Color.red())
                    await ctx.send(embed=embed)

                    self.market_halts += 1
                    self.last_market_value = 0.0

                    await asyncio.sleep(self.market_timeout)  # Sleep for 30 minutes

                    self.is_halted = False
                    embed = discord.Embed(description="Trading Resumed after 5 minutes.", color=discord.Color.green())
                    await ctx.send(embed=embed)

        self.last_market_value = etf_value


    async def check_stock_change(self, ctx, symbol: str):
        current_price = await get_stock_price(self, ctx, symbol)

        # Check if the symbol is already in self.stock_monitor
        if symbol not in self.stock_monitor:
            self.stock_monitor[symbol] = []  # Initialize an empty list for the symbol

        # Append the current price
        self.stock_monitor[symbol].append(current_price)

        # Check if the list has more than 5 entries, and if so, remove the oldest entries
        if len(self.stock_monitor[symbol]) > 5:
            self.stock_monitor[symbol] = self.stock_monitor[symbol][-5:]

            # Compare the oldest and latest prices
            oldest_price = self.stock_monitor[symbol][0]
            latest_price = self.stock_monitor[symbol][-1]
            percentage_change = ((latest_price - oldest_price) / oldest_price) * 100

            # Print a statement if the price change is more than 100%
            if self.stock_circuit_breaker == True:
                if abs(percentage_change) > self.stock_limit:
                    print(f"Trading Halted for {symbol} due to significant market change")
                    embed = discord.Embed(description=f"Trading Halted due to a significant market change for {symbol}. Waiting for {(self.stock_timeout / 60)} minutes.", color=discord.Color.red())
                    await ctx.send(embed=embed)
                    self.stock_halts += 1
                    self.not_trading.append(symbol.lower())
                    await asyncio.sleep(self.stock_timeout)
                    self.stock_monitor.pop(symbol)
                    self.not_trading.remove(symbol.lower())
                    return


    @commands.command(name="circuit_stats", aliases=["qsec_config", "qsec_stats"])
    async def circuit_stats(self, ctx):
        if self.is_halted:
            color=discord.Color.red()
        else:
            color=discord.Color.blue()
        embed = discord.Embed(title=f"QSec Platform Config/Stats for QSE Blockchain", color=discord.Color.blue())
        embed.add_field(name="Market Halted:", value=f"{self.is_halted}", inline=False)
        embed.add_field(name="Assets Halted", value=f"{self.not_trading}", inline=False)
        embed.add_field(name="Assets in Debug", value=f"{self.maintenance}", inline=False)
        embed.add_field(name="Market Circuit Breaker:", value=f"{self.market_circuit_breaker}", inline=False)
        embed.add_field(name="Market Circuit Limit:", value=f"{self.market_limit}%", inline=False)
        embed.add_field(name="Market Timeout:", value=f"{(self.market_timeout / 60):,.0f} minutes", inline=False)
        embed.add_field(name="Stock Circuit Breaker:", value=f"{self.stock_circuit_breaker}", inline=False)
        embed.add_field(name="Stock Circuit Limit:", value=f"{self.stock_limit}%", inline=False)
        embed.add_field(name="Stock Timeout:", value=f"{(self.stock_timeout / 60):,.0f} minutes", inline=False)
        embed.add_field(name="Current Pool Size:", value=f"{len(self.transaction_pool)}", inline=False)
        embed.add_field(name="Highest Pool Size:", value=f"{self.total_pool}", inline=False)
        embed.add_field(name="Market Halts since last Reload:", value=f"{self.market_halts}", inline=False)
        embed.add_field(name="Stock Halts since last Reload:", value=f"{self.stock_halts}", inline=False)
        active_users_today = await count_active_users(self, "daily")
        active_users_week = await count_active_users(self, "weekly")
        active_users_month = await count_active_users(self, "monthly")
        embed.add_field(name="Total Users Today:", value=f"{active_users_today:,.0f}", inline=False)
        embed.add_field(name="Total Users Weekly:", value=f"{active_users_week:,.0f}", inline=False)
        embed.add_field(name="Total Users Monthly:", value=f"{active_users_month:,.0f}", inline=False)


        await ctx.send(embed=embed)

    @commands.command(name="circuit_breaker")
    @is_allowed_user(930513222820331590, PBot)
    async def circuit_breaker(self, ctx, circuit: str, halt: bool):
        if circuit.lower() == "market":
            if halt == True:
                self.market_circuit_breaker = True
                embed = discord.Embed(description=f"{circuit} circuit breaker on", color=discord.Color.green())
                await ctx.send(embed=embed)
            else:
                self.market_circuit_breaker = False
                embed = discord.Embed(description=f"{circuit} circuit breaker off", color=discord.Color.red())
                await ctx.send(embed=embed)
        elif circuit.lower() == "stock":
            if halt == True:
                self.stock_circuit_breaker = True
                embed = discord.Embed(description=f"{circuit} circuit breaker on", color=discord.Color.green())
                await ctx.send(embed=embed)
            else:
                self.stock_circuit_breaker = False
                embed = discord.Embed(description=f"{circuit} circuit breaker off", color=discord.Color.red())
                await ctx.send(embed=embed)
        else:
            await ctx.send("Wrong Syntax")

    @commands.command(name="ban")
    @is_allowed_user(930513222820331590, PBot, 607050637292601354)
    async def ban_user(self, ctx, P3address, banned: bool):
        user_id = get_user_id(self.P3addrConn, P3address)
        timestamp_est = ctx.message.created_at.astimezone(timezone(timedelta(hours=-5)))
        # Send report to admin
        admin_user_id = 930513222820331590  # Replace with your admin user ID
        admin = await self.bot.fetch_user(admin_user_id)
        if banned:
            if user_id not in self.blacklisted:
                self.blacklisted.append(user_id)
                embed = discord.Embed(description=f"{P3address} Banned", color=discord.Color.red())
                admin_message = f"{get_p3_address(self.P3addrConn, ctx.author.id)} has banned {P3address}\n**Timestamp (EST):** {timestamp_est.strftime('%Y-%m-%d %H:%M:%S')}\n"
                await ctx.send(embed=embed)
        else:
            if user_id in self.blacklisted:
                self.blacklisted.remove(user_id)
                embed = discord.Embed(description=f"{P3address} Unbanned", color=discord.Color.green())
                admin_message = f"{get_p3_address(self.P3addrConn, ctx.author.id)} has unbanned {P3address}\n**Timestamp (EST):** {timestamp_est.strftime('%Y-%m-%d %H:%M:%S')}\n"
                await ctx.send(embed=embed)
        await admin.send(admin_message)

    @commands.command(name="halt_trading")
    @is_allowed_user(930513222820331590, PBot)
    async def halt_trading(self, ctx, halt: bool):
        if halt:
            self.is_halted = True
            self.is_halted_order = True
            embed = discord.Embed(description="Trading Halted", color=discord.Color.red())
            await ctx.send(embed=embed)
        else:
            self.is_halted = False
            self.is_halted_order = False
            embed = discord.Embed(description="Trading Resumed", color=discord.Color.green())
            await ctx.send(embed=embed)


    @commands.command(name="halt_trading_order")
    @is_allowed_user(930513222820331590, PBot)
    async def halt_trading_order(self, ctx, halt: bool):
        if halt:
            self.is_halted_order = True
            embed = discord.Embed(description="Trading Halted", color=discord.Color.red())
            await ctx.send(embed=embed)
        else:
            self.is_halted_order = False
            embed = discord.Embed(description="Trading Resumed", color=discord.Color.green())
            await ctx.send(embed=embed)

    @commands.command(name="halt_trading_stock")
    @is_allowed_user(930513222820331590, PBot)
    async def halt_trading_stock(self, ctx, stock:str, halt: bool):
        if halt:
            self.not_trading.append(stock.lower())
            embed = discord.Embed(description=f"Trading Halted for {stock}", color=discord.Color.red())
            await ctx.send(embed=embed)
        else:
            self.not_trading.remove(stock.lower())
            if stock in self.stock_monitor:
                self.stock_monitor.pop(stock)
            embed = discord.Embed(description=f"Trading Resumed for {stock}", color=discord.Color.green())
            await ctx.send(embed=embed)

    @commands.command(name="add_ipo")
    @is_allowed_user(930513222820331590, PBot)
    async def add_ipo(self, ctx, stock:str, ipo: bool):
        if ipo:
            self.ipo_stocks.append(stock.lower())
            embed = discord.Embed(description=f"{stock} added to IPO", color=discord.Color.green())
            await ctx.send(embed=embed)
        else:
            self.ipo_stocks.remove(stock.lower())
            embed = discord.Embed(description=f"{stock} removed from IPO", color=discord.Color.red())
            await ctx.send(embed=embed)


    async def process_transaction(self, ctx, type, symbol, amount, action):
        try:
            async with self.db_semaphore:
                async with self.transaction_lock:
                    if action == "buy":
                        if type.lower() == "order":
                            print("Order")
                            await self.transact_order2(ctx, str(symbol), int(amount))
                        elif type.lower() == "stock":
                            self.buy_timer_start = timeit.default_timer()
                            await self.buy_stock(ctx, symbol, amount)
                        elif type.lower() == "item":
                            self.buy_item_timer_start = timeit.default_timer()
                            await self.buy_item(ctx, symbol, amount)
                        elif type.lower() == "etf":
                            if not symbol.isdigit():
                                await ctx.send("Invalid ETF symbol. ETF symbol must be an integer.")
                                return
                            for i in self.etfs:
                                if symbol not in self.etfs:
                                    await ctx.send(f"ETF {symbol} does not exist")
                                    return
                            self.buy_etf_timer_start = timeit.default_timer()
                            await self.buy_etf(ctx, symbol, amount)
                        else:
                            await ctx.send(f"Transaction Error: {symbol} must be Stock, Item, or ETF")
                    else:
                        if type.lower() == "stock":
                            self.sell_timer_start = timeit.default_timer()
                            if symbol.lower() not in self.ipo_stocks:
                                await self.sell_stock(ctx, symbol, amount)
                            else:
                                embed = discord.Embed(description=f"{symbol} is in IPO and cannot be sold during the IPO Phase", color=discord.Color.red())
                                await ctx.send(embed=embed)
                                return
                        elif type.lower() == "item":
                            self.sell_item_timer_start = timeit.default_timer()
                            await self.sell_item(ctx, symbol, amount)
                        elif type.lower() == "etf":
                            if not symbol.isdigit():
                                embed = discord.Embed(description=f"Invalid ETF symbol. ETF symbol must be an integer.", color=discord.Color.red())
                                await ctx.send(embed=embed)
                                return
                            self.sell_etf_timer_start = timeit.default_timer()
                            await self.sell_etf(ctx, symbol, amount)
                        else:
                            embed = discord.Embed(description=f"Transaction Error: {symbol} must be Stock, Item, or ETF", color=discord.Color.red())
                            await ctx.send(embed=embed)
                            return
        except Exception as e:
            embed = discord.Embed(description=f"Transaction failed: for {symbol}\nTry again shortly...", color=discord.Color.red())
            await ctx.send(embed=embed)
            if str(e) != "404 Not Found (error code: 10008): Unknown Message":
                #self.skipped_transactions.append((ctx, type, symbol, amount, action))
                print(f"Transaction failed: {str(e)}")
        except sqlite3.Error as e:
            # Check if the error message contains the specific error
            if "Python int too large to convert to SQLite INTEGER" in str(e):
                embed = discord.Embed(description="Transaction Failed: Try a smaller quantity", color=discord.Color.red())
                await ctx.send(embed=embed)
                return

    async def process_transactions(self, ctx):
        # Define the width of the ASCII-like debug window
        window_width = 70

        def debug_print(message):
            for line in message.split('\n'):
                print(f"| {line:<{window_width - 3}} |")
            print("+" + "-" * (window_width - 2) + "+")

        debug_print("Grabbing Pool")
        while self.transaction_pool or self.skipped_transactions:
            debug_print("Acquiring Lock")
            async with self.transaction_lock:
                debug_print("Beginning Transaction")
                if self.skipped_transactions:
                    # Add skipped transactions back to the pool
                    self.transaction_pool.extend(self.skipped_transactions)
                    self.skipped_transactions = []

                if not self.transaction_pool:
                    break

                debug_print(f"Pool Size: {len(self.transaction_pool)}")
                debug_print(f"Skipped Pool Size: {len(self.skipped_transactions)}")

                if len(self.transaction_pool) > self.total_pool:
                    pool_difference = len(self.transaction_pool) - self.total_pool
                    self.total_pool += pool_difference

                # Extract transaction details
                ctx, type, symbol, amount, action = self.transaction_pool.pop(0)

            # Process the extracted transaction
            await self.process_transaction(ctx, type, symbol, amount, action)
            await self.check_market(ctx)



    @commands.command(name="set_all_stock_prices", help="Set the prices of all stocks to random values between 1 and 500.")
    @is_allowed_user(930513222820331590, PBot)
    async def set_all_stock_prices(self, ctx):
        cursor = self.conn.cursor()

        try:
            # Get all stock symbols
            cursor.execute("SELECT symbol FROM stocks")
            stocks = [row[0] for row in cursor.fetchall()]

            # Update the prices of all stocks
            for stock_name in stocks:
                new_price = random.randint(1, 500)
                cursor.execute("UPDATE stocks SET price = ? WHERE symbol = ?", (new_price, stock_name))

            self.conn.commit()
            await ctx.send("All stock prices have been updated successfully.")

        except sqlite3.Error as e:
            await ctx.send(f"An error occurred while updating stock prices: {str(e)}")



    @commands.command(name="order")
    @is_allowed_server(1161678765894664323, 1087147399371292732)
    async def place_order(self, ctx, order_type: str, symbol: str, price: str, quantity: str):
        quantity = int(quantity.replace(",", ""))
        new_price = price.replace(",", "")
        new_price = round(float(new_price))
        mv = await get_etf_value(self, ctx, 6)
        await add_mv_metric(self, ctx, mv)
        await add_etf_metric(self, ctx)
#        await add_metal_metric(self, ctx)
        cp = await get_stock_price(self, ctx, symbol)
        await add_reserve_metric(self, ctx)
        mv_avg = await calculate_average_mv(self)
        print(f"MV Avg: {mv_avg:,.2f}")
        if symbol.lower() in self.ipo_stocks and ctx.author.id != 607050637292601354:
            await ctx.send(f"{symbol} currently in IPO, cannot place orders")
            return

        if new_price < cp:
            await ctx.send(f"Price cannot be under {cp:,.2f} QSE per Share")
            return

        if order_type.lower() == "buy":
            await ctx.send("Buy Orders Disabled")
            return
            user_owned = self.get_user_stock_amount(ctx.author.id, symbol)
            result = await get_supply_stats(self, ctx, symbol)
            reserve, total, locked, escrow, market, circulating = result
            if (user_owned + int(quantity)) > (total * 0.18):
                embed = discord.Embed(description=f"{ctx.author.mention}, you cannot own more than 18%({(total * 0.18):,.0f}) of the total supply of {stock_name} stocks.\nAvailable: {market:,}\nTotal: {total:,}\nYour Shares: {user_owned:,}", color=discord.Color.red())
                await ctx.send(embed=embed)
                return
            else:
                user_owned = self.get_user_stock_amount(ctx.author.id, symbol)
                result = await get_supply_stats(self, ctx, symbol)
                reserve, total, locked, escrow, market, circulating = result
                escrow_user_shares = await get_total_shares_user_order(self, ctx.author.id, symbol)
                if (user_owned + int(quantity) + escrow_user_shares) > (total * 0.18):
                    embed = discord.Embed(description=f"{ctx.author.mention}, you cannot own more than 18%({(total * 0.18):,.0f}) of the total supply of {stock_name} stocks.\nAvailable: {market:,}\nTotal: {total:,}\nYour Shares + escrow: {user_owned:,} + {escrow_user_shares:,}", color=discord.Color.red())
                    await ctx.send(embed=embed)
                else:
                    await self.add_limit_order_command(ctx, symbol, order_type, price, quantity)
        elif order_type.lower() == "sell":
            user_owned = self.get_user_stock_amount(ctx.author.id, symbol)
            if user_owned < int(quantity):
                await ctx.send(f"Not enough {symbol} in stash")
                return
            else:
                current_price = await get_stock_price(self, ctx, symbol)
                margin = (current_price * 0.50) + current_price
                if new_price > margin + 1:
                    await ctx.send(f"Can't place orders higher than 50%({margin:,.2f}) of the current price({current_price:,.2f})")
                    return
                await self.add_limit_order_command(ctx, symbol, order_type, price, quantity)
                await add_experience(self, self.conn, ctx.author.id, 2.5, ctx)
        else:
            await ctx.send("Command syntax: !order order_type, symbol, price, quantity")




    @commands.command(name="add_limit_order", aliases=["place_order"], help="Add a limit order.")
    async def add_limit_order_command(self, ctx, symbol: str, order_type: str, price: str, quantity: int):
        max_share_limit = 500_000_000_000_000_000_000
        max_value_limit = 500_000_000_000_000_000_000_000
        if ',' in str(price):
            new_price = price.replace(",", "")
            new_price = round(float(new_price))

            order_value = int(quantity) * int(new_price)
        else:
            order_value = int(quantity) * int(price)

        no_order = ["p3:stable", "roflstocks"]
        if symbol.lower() in no_order:
            await ctx.send(f"Orders not allowed for {symbol}")
            return

        if order_type.lower() == "buy":
            lowest_sell = await lowest_price_order(self, ctx, "sell", symbol)
            highest_buy = await highest_price_order(self, ctx, "buy", symbol)

            if lowest_sell and int(price) > int(lowest_sell["price"]):
                await ctx.send(f"Buy order must be lower than {lowest_sell['price']:,.0f} QSE per Share")
                return

            if highest_buy and int(price) > int(highest_buy["price"]):
                await ctx.send(f"Buy order must be lower than {highest_buy['price']:,.0f} QSE per Share")
                return

        if order_type.lower() == "sell":
            highest = await highest_price_order(self, ctx, "buy", symbol)
            lowest = await lowest_price_order(self, ctx, "sell", symbol)
            if highest and lowest:
                if int(highest["price"]) > int(lowest["price"]):
                    await ctx.send(f"Sell order must be higher than {highest['price']:,.0f} QSE per Share")
                    return
            if highest:
                if int(price) < int(highest["price"]):
                    await ctx.send(f"Sell order must be higher than {highest['price']:,.0f} QSE per Share")
                    return

        user_id = ctx.author.id

        # Determine if the order needs to be broken into chunks
        if int(quantity) > max_share_limit or order_value >= max_value_limit:
            # Use larger chunks without exceeding the limits
            max_chunk_size = min(max_share_limit, max_value_limit // price)
            chunks = int((quantity + max_chunk_size - 1) / max_chunk_size)  # Fix: Convert to int
            chunk_quantity = int(quantity) // chunks
        else:
            chunks = 1
            chunk_quantity = int(quantity)

        orders = []
        for _ in range(chunks):
            orders.append((self, ctx, user_id, symbol, order_type, price, chunk_quantity))
        await add_limit_orders(self, ctx, orders, True)



    @commands.command(name="add_limit_order_bot", aliases=["place_order_bot"], help="Add a limit order.")
    async def add_limit_order_bot(self, ctx, symbol: str, price: float, quantity: int):
        try:
            await add_limit_order(self, ctx, symbol, price, quantity)
            await ctx.send("Order listed")
        except:
            await ctx.send("Failed to list order")




    @commands.command(name="mint")
    @is_allowed_user(930513222820331590, PBot)
    async def mint_qse(self, ctx, amount):
        amount = int(amount)
        old_balance = get_user_balance(self.conn, PBot)
        await mint_to_reserve(self, ctx, amount)
        new_balance = get_user_balance(self.conn, PBot)
        mv = await get_etf_value(self, ctx, 6)
        await add_mv_metric(self, ctx, mv)
        await add_etf_metric(self, ctx)
        await add_reserve_metric(self, ctx)
        await ctx.send(f"Minted {amount:,.0f} QSE to the Reserve\n\nPrevious Funds: {old_balance:,.2f}\nNew Funds: {new_balance:,.2f}")




    @commands.command(name="remove_order", help="Remove a limit order by order_id.")
    @is_allowed_user(930513222820331590, PBot)
    async def remove_limit_order_command(self, ctx, order_id: int):
        await remove_limit_order(self, ctx, order_id)

    @commands.command(name="read_limit_orders", help="Read all limit orders.")
    @is_allowed_user(930513222820331590, PBot)
    async def read_limit_orders_command(self, ctx):
        await read_limit_orders(self, ctx)


    @commands.command(name="lowest_price_order", help="Show the lowest price order based on type and symbol.")
    async def lowest_price_order_command(self, ctx, order_type: str, symbol: str, highlow: str):
        if highlow == "low":
            result = await lowest_price_order(self, ctx, order_type, symbol)
        elif highlow == "high":
            result = await highest_price_order(self, ctx, order_type, symbol)
        else:
            return
        if result:
            print(f"Order ID: {result['order_id']}")
            print(f"User ID: {result['user_id']}")
            print(f"Symbol: {result['symbol']}")
            print(f"Order Type: {result['order_type']}")
            print(f"Price: {result['price']}")
            print(f"Quantity: {result['quantity']}")
            print(f"Created At: {result['created_at']}")
        else:
            print(f"No {order_type} order for {symbol}")

    @commands.command(name="buy", help="Buy Stocks, ETFs, and Items")
    @is_allowed_server(1161678765894664323, 1087147399371292732)
    async def buy(self, ctx, type: str, symbol = None, amount = None):
        if amount != None:
            if isinstance(amount, str):
                amount = int(amount.replace(",", ""))
        userid = ctx.author.id
        if userid in self.blacklisted:
            await ctx.send("Your address has been blacklisted")
            return


        if check_current_hp(userid) == 0:
            embed = discord.Embed(description="Your HP is zero, Please Heal", color=discord.Color.red())
            await ctx.send(embed=embed)
            return

        if type.lower() == "option":
            await ctx.send("UpDown Derivatives are Temporarily turned off")
            return
            if amount == "None":
                await ctx.send("UpDown Derivatives are Temporarily turned off")
                return
                await self.buy_option(ctx, symbol)
                return
            else:
                if amount > 100_000:
                    chunks = (amount // 100_000)  # Use integer division to get whole chunks
                    chunk_amount = amount // chunks  # Calculate the amount per chunk
                    remaining_amount = amount % chunks  # Calculate the remaining amount
                    for _ in range(chunks):
                        await self.buy_option(ctx, symbol, chunk_amount)
                        if remaining_amount > 0:
                            await self.buy_option(ctx, symbol, remaining_amount)
                else:
                    await self.buy_option(ctx, symbol, amount)
                    return


        if type.lower() == "order":

            if self.is_halted_order:
                embed = discord.Embed(description="Order Trading Halted", color=discord.Color.red())
                await ctx.send(embed=embed)
                return
            else:
                try:
                    user_id = ctx.author.id
                    p3addr = get_p3_address(self.P3addrConn, user_id)




                    debug_buy_wrapper(type, symbol, amount, user_id, p3addr)
#                    print(f"\n\nDebug Buy Wrapper\nType: {type}\nAsset: {symbol}\nQuantity: {amount:,.0f}\nUserID: {user_id}\nP3 Address: {p3addr}\n\n")
                    self.transaction_pool.append((ctx, type, symbol, amount, "buy"))
                    if len(self.transaction_pool) != 0:
                        print("+" + "-" * (70 - 2) + "+")
                        print(f"|{'Processing Transaction':^{70 - 2}}|")
                        print("+" + "-" * (70 - 2) + "+")
                        await self.process_transactions(ctx)
                        await autoliquidate(self, ctx)
                        if symbol in inverseStocks:
                            await self.mint_stock_supply(ctx, symbol, round(amount * 4), False)
                    return
                except discord.errors.GatewayNotFound as e:
                    print(f"Gateway not found warning: {e}")
                    await ctx.send("Warning: Gateway not found. canceling order")
                    return
                except sqlite3.Error as e:
                    # Check if the error message contains the specific error
                    if "Python int too large to convert to SQLite INTEGER" in str(e):
                        embed = discord.Embed(description="Transaction Failed: Try a smaller quantity", color=discord.Color.red())
                        await ctx.send(embed=embed)
                        return

        if type.lower() == "stock":
            is_open, day_type = await is_trading_hours()
            if is_open:
                print("The market is open during trading hours on", day_type)
            else:
                await ctx.send("The market is closed.\nMarket Hours 7am-7pm EST\n\nOrder Books open 24/7")
                return
            current_price = await get_stock_price(self, ctx, symbol)
            value = int(current_price) * int(amount)
            if int(value) > 10_000_000_000_000_000_000_000:
                embed = discord.Embed(description="Can only purchase 10,000,000,000,000,000,000,000 of value at a time", color=discord.Color.red())
                await ctx.send(embed=embed)
                return
            order_price = await lowest_price_order(self, ctx, "sell", symbol)
            total_supply, available = await get_supply_info(self, ctx, symbol)
            result = await get_supply_stats(self, ctx, symbol)
            reserve, total_supply, locked, escrow, market, circulating = result
            escrowe_supply = escrow
            reserve_supply = reserve

            if reserve_supply == 0:
                if self.is_halted_order:
                    embed = discord.Embed(description="Order Trading Halted", color=discord.Color.red())
                    await ctx.send(embed=embed)
                    return
                else:
                    try:
                        user_id = ctx.author.id
                        p3addr = get_p3_address(self.P3addrConn, user_id)



                        debug_buy_wrapper(type, symbol, amount, user_id, p3addr)
#                        print(f"\n\nDebug Buy Wrapper\nType: {type}\nAsset: {symbol}\nQuantity: {amount:,.0f}\nUserID: {user_id}\nP3 Address: {p3addr}\n\n")
                        self.transaction_pool.append((ctx, type, symbol, amount, "buy"))
                        if len(self.transaction_pool) != 0:
                            print("+" + "-" * (70 - 2) + "+")
                            print(f"|{'Processing Transaction':^{70 - 2}}|")
                            print("+" + "-" * (70 - 2) + "+")
                            await self.process_transactions(ctx)
                            await autoliquidate(self, ctx)

                        return
                    except discord.errors.GatewayNotFound as e:
                        print(f"Gateway not found warning: {e}")
                        await ctx.send("Warning: Gateway not found. canceling order")
                        return
                    except sqlite3.Error as e:
                        # Check if the error message contains the specific error
                        if "Python int too large to convert to SQLite INTEGER" in str(e):
                            embed = discord.Embed(description="Transaction Failed: Try a smaller quantity", color=discord.Color.red())
                            await ctx.send(embed=embed)
                            return


            if reserve_supply < amount:
                embed = discord.Embed(description=f"Only {reserve_supply} shares", color=discord.Color.blue())
                await ctx.send(embed=embed)
                return


        if symbol.lower() in self.ipo_stocks and current_price > self.ipo_price_limit:
            self.ipo_stocks.remove(symbol.lower())
            embed = discord.Embed(description=f"{symbol} has left IPO @everyone", color=discord.Color.green())
            await ctx.send(embed=embed)
            return
        if len(self.transaction_pool) > 0:
            embed = discord.Embed(description=f"Transaction Pending, you have {len(self.transaction_pool)} ahead of you. ", color=discord.Color.yellow())
            await ctx.send(embed=embed)


        if await self.is_trading_halted() == True:
            embed = discord.Embed(description="Trading Temporarily Halted", color=discord.Color.red())
            await ctx.send(embed=embed)
            return
        if await self.is_trading_halted_stock(symbol) == True:
            embed = discord.Embed(description=f"Trading Temporarily Halted for {symbol}", color=discord.Color.red())
            await ctx.send(embed=embed)
            return
        await check_store_addr(self, ctx)
        if type.lower() == "stock":
            await self.check_stock_change(ctx, symbol)
        user_id = ctx.author.id
        p3addr = get_p3_address(self.P3addrConn, user_id)

        try:
            debug_buy_wrapper(type, symbol, amount, user_id, p3addr)
#            print(f"\n\nDebug Buy Wrapper\nType: {type}\nAsset: {symbol}\nQuantity: {amount:,.0f}\nUserID: {user_id}\nP3 Address: {p3addr}\n\n")
            async with self.transaction_lock:
                self.transaction_pool.append((ctx, type, symbol, amount, "buy"))
            if len(self.transaction_pool) != 0:
                print("+" + "-" * (70 - 2) + "+")
                print(f"|{'Processing Transaction':^{70 - 2}}|")
                print("+" + "-" * (70 - 2) + "+")
                await self.process_transactions(ctx)
                await autoliquidate(self, ctx)
                mv = await get_etf_value(self, ctx, 6)
                await add_mv_metric(self, ctx, mv)
                await add_etf_metric(self, ctx)
                await add_reserve_metric(self, ctx)
                mv_avg = await calculate_average_mv(self)
                print(f"MV Avg: {mv_avg:,.2f}")
        except ValueError:
            await ctx.send("Invalid amount. Please provide a valid integer.")

    @commands.command(name="sell", help="Sell Stocks, ETFs, and Items")
    @is_allowed_server(1161678765894664323, 1087147399371292732)
    @is_not_allowed_user(1224458697728593962, 1224461917448437892, 1224463766956015670, 1224465106835083348)
    async def sell(self, ctx, type: str, symbol, amount):
        if ctx.author.id in self.blacklisted:
            await ctx.send("Your address has been blacklisted")
            return



        if check_current_hp(ctx.author.id) == 0:
            embed = discord.Embed(description="Your HP is zero, Please Heal", color=discord.Color.red())
            await ctx.send(embed=embed)
            return
        if isinstance(amount, str):
            amount = int(amount.replace(",", ""))

        if len(self.transaction_pool) > 0:
            embed = discord.Embed(description=f"Transaction Pending, you have {len(self.transaction_pool)} ahead of you. ", color=discord.Color.yellow())
            await ctx.send(embed=embed)
        if await self.is_trading_halted() == True:
            await ctx.send("All Trading Temporarily Halted")
            return
        if await self.is_trading_halted_stock(symbol) == True:
            embed = discord.Embed(description=f"Trading Temporarily Halted for {symbol}", color=discord.Color.red())
            await ctx.send(embed=embed)
            return

        await check_store_addr(self, ctx)
        if type.lower() == "order":
            mv = await get_etf_value(self, ctx, 6)
            await add_mv_metric(self, ctx, mv)
            await add_etf_metric(self, ctx)
            await add_reserve_metric(self, ctx)
            mv_avg = await calculate_average_mv(self)
            print(f"MV: {mv:,.2f}\nMV Avg: {mv_avg:,.2f}")
            current_price = await get_stock_price(self, ctx, symbol)
            margin = (current_price * 0.50) + current_price
            margin = round(float(margin))

            await self.add_limit_order_command(ctx, symbol, "sell", margin, amount)
            await add_experience(self, self.conn, ctx.author.id, 2.5, ctx)
            return
        if type.lower() == "stock":
#            await ctx.send("Selling to Reserve turned off, try buying/selling off orderbooks")
#            return
            is_open, day_type = await is_trading_hours()
            if is_open:
                print("The market is open during trading hours on", day_type)
            else:
                await ctx.send("The market is closed.\nMarket Hours 7am-7pm EST\n\nOrder Books open 24/7")
                return
            await self.check_stock_change(ctx, symbol)
        user_id = ctx.author.id
        p3addr = get_p3_address(self.P3addrConn, user_id)

        try:
            print(f"Debug Sell Wrapper\nType: {type}\nAsset: {symbol}\nQuantity: {amount}\nUserID: {user_id}\nP3 Address: {p3addr}")
            async with self.transaction_lock:
                self.transaction_pool.append((ctx, type, symbol, amount, "sell"))

            if len(self.transaction_pool) != 0:
                print(f"Pool Size: {len(self.transaction_pool)}")
                print("+" + "-" * (70 - 2) + "+")
                print(f"|{'Processing Transaction':^{70 - 2}}|")
                print("+" + "-" * (70 - 2) + "+")
                await self.process_transactions(ctx)
                await autoliquidate(self, ctx)
                mv = await get_etf_value(self, ctx, 6)
                await add_mv_metric(self, ctx, mv)
                await add_etf_metric(self, ctx)
#        await add_metal_metric(self, ctx)
                await add_reserve_metric(self, ctx)
                mv_avg = await calculate_average_mv(self)
            print(f"MV Avg: {mv_avg:,.2f}")
        except ValueError:
            await ctx.send("Invalid amount. Please provide a valid integer.")

    @commands.command(name="casino", help="Buy Stocks, ETFs, and Items")
    async def casino(self, ctx, game: str, choice, amount):
        await check_store_addr(self, ctx)
        user_id = ctx.author.id
        p3addr = get_p3_address(self.P3addrConn, user_id)

        try:
            amount = int(amount.replace(",", ""))
            print(f"Debug Casino Wrapper\nGame: {game}\nChoice: {choice}\nBet: {amount}\nUserID: {user_id}\nP3 Address: {p3addr}")
            async with self.transaction_lock:
                self.transaction_pool.append((ctx, game, choice, amount, "casino"))
                print(f"Pool Size: {len(self.transaction_pool)}")
            if len(self.transaction_pool) == 1:
                print("+" + "-" * (70 - 2) + "+")
                print(f"|{'Processing Transaction':^{70 - 2}}|")
                print("+" + "-" * (70 - 2) + "+")
                await self.process_transactions()
        except ValueError:
            await ctx.send("Invalid amount. Please provide a valid integer.")


    @commands.command(name='reserve_chart')
    async def reserve_chart(self, ctx):
        try:
            cursor = self.conn.cursor()

            # Retrieve data for each metric
            cursor.execute("SELECT qse FROM reserve_value")
            qse_values = cursor.fetchall()

            cursor.execute("SELECT stocks FROM reserve_value")
            stocks_values = cursor.fetchall()

            cursor.execute("SELECT total FROM reserve_value")
            total_values = cursor.fetchall()

            if not qse_values and not stocks_values and not total_values:
                await ctx.send("No data available for the specified metrics.")
                return

            # Extract values from the result sets
            qse_values = [float(value[0]) for value in qse_values]
            stocks_values = [float(value[0]) for value in stocks_values]
            total_values = [float(value[0]) for value in total_values]

            # Calculate percentage change
            qse_percentage_change = np.array(qse_values) / qse_values[0] * 100 - 100
            stocks_percentage_change = np.array(stocks_values) / stocks_values[0] * 100 - 100
            total_percentage_change = np.array(total_values) / total_values[0] * 100 - 100

            # Create and save the chart with dark mode
            plt.style.use('dark_background')
            plt.figure(figsize=(20, 15))  # Adjust figure size as needed

            # Plot each metric
            plt.subplot(2, 1, 1)  # Two subplots, first one for raw values
            plt.plot(qse_values, label='QSE')
            plt.plot(stocks_values, label='Stocks')
            plt.plot(total_values, label='Total')

            plt.xlabel('Index', fontsize=14)
            plt.ylabel('Reserve Value', fontsize=14)
            plt.title('Reserve Value Chart (Raw Values)', fontsize=16)
            plt.legend(fontsize=12)
            plt.ticklabel_format(style='plain', useOffset=False, axis='y')
            plt.gca().yaxis.set_major_formatter(
                ticker.FuncFormatter(lambda x, _: "{:,.2f}".format(x))
            )
            plt.xticks(rotation=45, fontsize=12)
            plt.yticks(fontsize=12)

            # Plot percentage change
            plt.subplot(2, 1, 2)  # Two subplots, second one for percentage change
            plt.plot(qse_percentage_change, label='QSE')
            plt.plot(stocks_percentage_change, label='Stocks')
            plt.plot(total_percentage_change, label='Total')

            plt.xlabel('Index', fontsize=14)
            plt.ylabel('Percentage Change (%)', fontsize=14)
            plt.title('Reserve Value Chart (Percentage Change)', fontsize=16)
            plt.legend(fontsize=12)
            plt.ticklabel_format(style='plain', useOffset=False, axis='y')
            plt.xticks(rotation=45, fontsize=12)
            plt.yticks(fontsize=12)
            plt.ylim(min(qse_percentage_change.min(), stocks_percentage_change.min(), total_percentage_change.min()) - 100,
                     max(qse_percentage_change.max(), stocks_percentage_change.max(), total_percentage_change.max()) + 100)

            plt.tight_layout()  # Ensure proper layout spacing
            plt.savefig('reserve_chart.png')

            # Send the chart to the Discord channel
            with open('reserve_chart.png', 'rb') as file:
                chart_file = discord.File(file)
                await ctx.send(file=chart_file)

            # Create and send the embed
            embed = discord.Embed(title="Reserve Value COT", color=discord.Color.blue())
            embed.add_field(name="QSE", value=f"{qse_percentage_change[-1]:,.2f}%", inline=False)
            embed.add_field(name="Stocks", value=f"{stocks_percentage_change[-1]:,.2f}%", inline=False)
            embed.add_field(name="Total", value=f"{total_percentage_change[-1]:,.2f}%", inline=False)

            await ctx.send(embed=embed)

        except sqlite3.Error as e:
            print(f"SQLite error occurred: {str(e)}")
            await ctx.send("An error occurred while processing the chart.")
        except Exception as e:
            print(f"An unexpected error occurred: {str(e)}")
            await ctx.send("An unexpected error occurred while processing the chart.")
        else:
            cursor.close()


    @commands.command(name='order_book_chart')
    async def order_book_chart(self, ctx, symbol: str):
        try:
            cursor = self.conn.cursor()

            # Retrieve buy orders
            cursor.execute("""
                SELECT price, SUM(quantity) as cumulative_quantity
                FROM limit_orders
                WHERE symbol = ? AND order_type = 'buy'
                GROUP BY price
                ORDER BY price DESC
            """, (symbol,))
            buy_data = cursor.fetchall()

            # Retrieve sell orders
            cursor.execute("""
                SELECT price, SUM(quantity) as cumulative_quantity
                FROM limit_orders
                WHERE symbol = ? AND order_type = 'sell'
                GROUP BY price
                ORDER BY price ASC
            """, (symbol,))
            sell_data = cursor.fetchall()

            if not buy_data and not sell_data:
                await ctx.send(f"No buy or sell orders available for {symbol}.")
                return

            # Calculate cumulative quantities for buy orders
            buy_prices, buy_cumulative_quantities = zip(*buy_data) if buy_data else ([], [])

            # Calculate cumulative quantities for sell orders
            sell_prices, sell_cumulative_quantities = zip(*sell_data) if sell_data else ([], [])

            # Plot the order book depth chart
            plt.style.use('dark_background')
            plt.figure(figsize=(20, 15))

            if buy_data:
                # Plot buy orders
                if sell_data:
                    # If both buy and sell data are available, use stacked bar chart
                    plt.bar(buy_prices, buy_cumulative_quantities, label='Buy Orders', color='green')
                else:
                    # If only buy data is available, use plot instead of bar
                    plt.plot(buy_prices, buy_cumulative_quantities, label='Buy Orders', color='green')

            if sell_data:
                # Plot sell orders on top of buy orders
                if buy_data:
                    # If both buy and sell data are available, use stacked bar chart
                    plt.bar(sell_prices, sell_cumulative_quantities, label='Sell Orders', color='red', bottom=buy_cumulative_quantities)
                else:
                    # If only sell data is available, use plot instead of bar
                    plt.plot(sell_prices, sell_cumulative_quantities, label='Sell Orders', color='red')

            plt.xlabel('Price')
            plt.ylabel('Cumulative Quantity')
            plt.title(f'Order Book Depth Chart - {symbol}')
            plt.legend()
            plt.grid(True)

            # Format y-axis labels with commas and two decimals
            plt.gca().yaxis.set_major_formatter(
                ticker.FuncFormatter(lambda x, _: "{:,.0f}".format(x))
            )

            # Format x-axis labels with non-scientific notation
            plt.ticklabel_format(style='plain', useOffset=False, axis='x')

            # Send the chart to the Discord channel
            plt.savefig('order_book_chart.png')
            plt.close()

            with open('order_book_chart.png', 'rb') as file:
                chart_file = discord.File(file)
                await ctx.send(file=chart_file)

        except sqlite3.Error as e:
            print(f"An error occurred: {str(e)}")
            await ctx.send("An error occurred while processing the chart.")




    @commands.command(name='market_chart')
    async def market_chart(self, ctx):
        try:
            cursor = self.conn.cursor()
            cursor.execute("SELECT mv FROM market_value")
            values = cursor.fetchall()

            if not values:
                await ctx.send("The market_value table is empty.")
                self.conn.close()
                return

            # Extract values from the result set
            values = [float(value[0]) for value in values]

            # Calculate RSI, Average Price, and Bollinger Bands
            rsi_period = 14  # Adjust as needed
            rsi_values = talib.RSI(np.array(values), timeperiod=rsi_period)
            average_price = np.mean(values)
            ath = np.max(values)
            atl = np.min(values)
            cmv = values[-1]  # Current Market Value

            # Calculate Moving Average (MA), Exponential Moving Average (EMA), and Simple Moving Average (SMA)
            ma_period = 20  # Adjust as needed
            ema_period = 20  # Adjust as needed
            ma_values = talib.MA(np.array(values), timeperiod=ma_period)
            ema_values = talib.EMA(np.array(values), timeperiod=ema_period)
            sma_values = talib.SMA(np.array(values), timeperiod=ma_period)

            # Calculate Rolling High and Low
            rolling_period = 14  # Adjust as needed
            rolling_high = np.maximum.accumulate(values)
            rolling_low = np.minimum.accumulate(values)

            # Calculate ROC and ATR
            roc_values = talib.ROC(np.array(values), timeperiod=1)  # Adjust as needed
            atr_values = talib.ATR(rolling_high, rolling_low, np.array(values), timeperiod=14)  # Adjust as needed

            # Calculate percentage change from ATL and ATH
            atl_percentage = ((np.array(values) - atl) / atl) * 100
            ath_percentage = ((np.array(values) - ath) / ath) * 100

            # Create and save the main chart with dark mode
            plt.style.use('dark_background')
            fig, axes = plt.subplots(nrows=5, ncols=1, figsize=(20, 20), sharex=True)

            # Plot market values
            axes[0].plot(values, label=f'Market Value ({cmv:,.2f})', color='cyan')
            axes[0].plot(sma_values, label=f'SMA ({ma_period})', color='yellow', alpha=0.5)  # Add SMA line
            axes[0].axhline(y=average_price, color='cyan', linestyle='--', label=f'Avg Value ({average_price:,.2f})')
            axes[0].axhline(y=ath, color='green', linestyle=':', label=f'ATH ({ath:,.2f})')
            axes[0].axhline(y=atl, color='red', linestyle=':', label=f'ATL ({atl:,.2f})')
            axes[0].set_ylabel('Market Value', fontsize=14)
            axes[0].set_title('Market Value Chart', fontsize=16)
            axes[0].ticklabel_format(style='plain', useOffset=False, axis='y')  # Disable scientific notation
            # Format y-axis labels with commas and two decimals
            axes[0].yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: "{:,.2f}".format(x)))
            axes[0].legend(fontsize=14, loc='best')

            # Plot RSI and ROC on the same subplot
            axes[1].plot(rsi_values, label='RSI', color='orange', alpha=0.5)
            axes[1].axhline(y=70, color='r', linestyle='--', label='Overbought (70)')
            axes[1].axhline(y=30, color='g', linestyle='--', label='Oversold (30)')
            axes[1].set_ylabel('RSI', fontsize=14)
            axes[1].set_title('RSI', fontsize=14)
            axes[1].ticklabel_format(style='plain', useOffset=False, axis='y')
            axes[1].legend(fontsize=14)

            # Plot Percentage Change from ATL and ATH
            axes[2].plot(atl_percentage, label='Percentage Change from ATL', color='red')
            axes[2].plot(ath_percentage, label='Percentage Change from ATH', color='green')
            axes[2].axhline(y=0, color='cyan', linestyle='--', label='Current Value')
            axes[2].set_ylabel('Percentage Change (%)', fontsize=14)
            axes[2].set_title('Percentage Change from ATL and ATH', fontsize=14)
            axes[2].ticklabel_format(style='plain', useOffset=False, axis='y')
            axes[2].legend(fontsize=14, loc='best')

            # Plot ATR
            axes[3].plot(atr_values, label='ATR', color='yellow')
            axes[3].set_xlabel('Index', fontsize=14)
            axes[3].set_ylabel('ATR', fontsize=14)
            axes[3].set_title('ATR', fontsize=14)
            axes[3].ticklabel_format(style='plain', useOffset=False, axis='y')
            axes[3].legend(fontsize=14, loc='best')


            # Plot RSI and ROC on the same subplot
            axes[4].plot(roc_values, label='ROC', color='cyan')  # Combine with RSI
            axes[4].set_ylabel('ROC', fontsize=14)
            axes[4].set_title('ROC', fontsize=14)
            axes[4].ticklabel_format(style='plain', useOffset=False, axis='y')
            axes[4].legend(fontsize=14)

            plt.tight_layout()  # Ensure proper layout spacing
            plt.savefig('market_chart.png')
            plt.close()

            # Send the chart to the Discord channel
            with open('market_chart.png', 'rb') as file:
                chart_file = discord.File(file)
                await ctx.send(file=chart_file)

        except sqlite3.Error as e:
            print(f"An error occurred: {str(e)}")
            await ctx.send("An error occurred while processing the chart.")


    @commands.command(name="depth", help="Show buy/sell depth of a stock.")
    async def show_depth(self, ctx, symbol: str, users: bool = False, depth_limit: int = 10):
        try:
            cursor = self.conn.cursor()

            if users:
                # Fetch all buy orders for the specified symbol
                cursor.execute("""
                    SELECT price, SUM(quantity) as total_quantity FROM limit_orders
                    WHERE order_type = 'buy' AND symbol = ?
                    GROUP BY price
                """, (symbol,))
                buy_orders = cursor.fetchall()

                # Fetch all sell orders for the specified symbol
                cursor.execute("""
                    SELECT price, SUM(quantity) as total_quantity FROM limit_orders
                    WHERE order_type = 'sell' AND symbol = ?
                    GROUP BY price
                """, (symbol,))
                sell_orders = cursor.fetchall()
            else:
                # Fetch all buy orders for the specified symbol
                cursor.execute("""
                    SELECT price, SUM(quantity) as total_quantity FROM limit_orders
                    WHERE order_type = 'buy' AND symbol = ? AND user_id != ?
                    GROUP BY price
                """, (symbol, ctx.author.id))
                buy_orders = cursor.fetchall()

                # Fetch all sell orders for the specified symbol
                cursor.execute("""
                    SELECT price, SUM(quantity) as total_quantity FROM limit_orders
                    WHERE order_type = 'sell' AND symbol = ? AND user_id != ?
                    GROUP BY price
                """, (symbol, ctx.author.id))
                sell_orders = cursor.fetchall()

            # Remove commas from the prices and convert them to floats
            for order in buy_orders + sell_orders:
                if ',' in str(order['price']):
                    order['price'] = float(order['price'].replace(',', ''))

            # Calculate the overall market price using the full set of orders
            all_orders = buy_orders + sell_orders
            weighted_average_price = sum(order['price'] * order['total_quantity'] for order in all_orders) / sum(order['total_quantity'] for order in all_orders)

            def format_order(order):
                total_value = order['price'] * order['total_quantity']
                return f"Price: {order['price']:.2f}\nTotal Quantity: {order['total_quantity']:,}\n"

            # Display only a limited number of orders based on the depth limit
            buy_depth_info = "\n".join([format_order(order) for order in buy_orders[:depth_limit]])
            sell_depth_info = "\n".join([format_order(order) for order in sell_orders[:depth_limit]])

            # Calculate the total value of the entire depth
            buy_value_depth = sum(order['price'] * order['total_quantity'] for order in buy_orders)
            sell_value_depth = sum(order['price'] * order['total_quantity'] for order in sell_orders)
            total_value_depth = buy_value_depth + sell_value_depth

            # Get the current price
            current_price = await get_stock_price(self, ctx, symbol)

            # Get the total user shares
            total_user_shares = await get_total_shares_user_order(self, ctx.author.id, symbol)

            # Calculate the percentage of total user shares against all order book shares
            if total_value_depth != 0:
                user_shares_percentage = (total_user_shares * current_price / total_value_depth) * 100
            else:
                user_shares_percentage = 0

            if users:
                embed = discord.Embed(title=f"Buy/Sell Depth for {symbol} with your orders", color=discord.Color.blue())
            else:
                embed = discord.Embed(title=f"Buy/Sell Depth for {symbol} w/out your orders", color=discord.Color.blue())
            embed.add_field(name="Buy Depth", value=buy_depth_info, inline=False)
            embed.add_field(name="Sell Depth", value=sell_depth_info, inline=False)
            embed.add_field(name="", value=f"-------------------------------------", inline=False)
            embed.add_field(name="Total Value of Buy Orders", value=f"{buy_value_depth:,.2f} QSE", inline=False)
            embed.add_field(name="Total Value of Sell Orders", value=f"{sell_value_depth:,.2f} QSE", inline=False)
            embed.add_field(name="Total Value of Depth", value=f"{total_value_depth:,.2f} QSE", inline=False)
            embed.add_field(name="Average Market Price", value=f"{weighted_average_price:,.2f} QSE", inline=False)
            result = await lowest_price_order(self, ctx, "sell", symbol)
            embed.add_field(name="Current Market Price", value=f"{current_price:,.2f} QSE", inline=False)
            embed.add_field(name="Your Shares in Escrow", value=f"{total_user_shares:,.0f} ({user_shares_percentage:.4f}%) Shares", inline=False)

            await ctx.send(embed=embed)
            await self.order_book_chart(ctx, symbol)

        except sqlite3.Error as e:
            embed = discord.Embed(description=f"An error occurred while fetching the buy/sell depth: {e}")
            await ctx.send(embed=embed)
        except ZeroDivisionError:
            embed = discord.Embed(description=f"No orders found for {symbol}")
            await ctx.send(embed=embed)
        except Exception as e:
                embed = discord.Embed(description=f"An error occurred while fetching the buy/sell depth: {e}")
                await ctx.send(embed=embed)


    @commands.command(name="send_from_reserve")
    @is_allowed_user(930513222820331590, PBot)
    async def send_from_reserve(self, ctx, user_id, amount: int):


        mv_avg = await calculate_average_mv(self)
        print(f"MV Avg: {mv_avg:,.2f}")
        reserve_funds = get_user_balance(self.conn, PBot)
        amount_percentage = (amount / reserve_funds) * 100
        if amount_percentage > 10:
            print(f"Emergency Minting {amount:,.2f} QSE to the Reserve")
            await mint_to_reserve(self, ctx, amount)
            print(f"Reserve {amount_percentage:,.2f}")
        else:
            print(f"Reserve {amount_percentage:,.2f}")
        # Check if the amount is over 100 trillion
        if amount > 9_000_000_000_000_000_000:
            chunks = (amount + 99_999_999_999_999_999_999) // 9_000_000_000_000_000_000  # Calculate the number of chunks
            chunk_amount = amount // chunks  # Calculate the amount per chunk
        else:
            chunks = 1
            chunk_amount = amount

        for _ in range(chunks):
            current_balance = get_user_balance(self.conn, user_id)
            print(f"{chunks:,.0f}:{chunk_amount:,.0f}")
            chunk_amount = Decimal(chunk_amount)
            new_balance = current_balance + chunk_amount
            await update_user_balance(self.conn, user_id, new_balance)

            reserve_balance = get_user_balance(self.conn, PBot)
            updated_balance = reserve_balance - chunk_amount
            await update_user_balance(self.conn, PBot, updated_balance)
            chunks -= 1



    @commands.command(name="cancel_order", help="Cancel an order by providing its order ID.")
#    @is_allowed_user(930513222820331590, PBot)
    async def cancel_order(self, ctx, order_id: int):
        try:
            cursor = self.conn.cursor()

            # Check if the order with the given ID exists and belongs to the user
            cursor.execute("""
                SELECT * FROM limit_orders
                WHERE order_id = ? AND user_id = ?
            """, (order_id, ctx.author.id))
            order = cursor.fetchone()

            if order:
                target = get_p3_address(self.P3addrConn, order["user_id"])
                if order["order_type"].lower() == "buy":
                    tax_percentage = self.calculate_tax_percentage(ctx, "buy_stock")
                    cost = order["quantity"] * order["price"]
                    fee = Decimal(cost) * Decimal(tax_percentage)
                    await self.send_from_reserve(ctx, ctx.author.id, (int(cost) - int(fee)))
                    print(f"""
                        Address: {target}
                        Refund: {cost:,}
                        Gas: {fee:,}
                    """)
                else:
                    sender_addr = get_p3_address(self.P3addrConn, PBot)
                    await send_stock(self, ctx, target, sender_addr, order["symbol"], order["quantity"], False)
#                    await self.give_stock(ctx, target, order["symbol"], order["quantity"], False)
                    print(f"""
                        Address: {target}
                        Refund Stock: {order["symbol"]}
                        Amount: {order["quantity"]:,}
                    """)

                # Perform the cancellation by deleting the order
                cursor.execute("""
                    DELETE FROM limit_orders
                    WHERE order_id = ?
                """, (order_id,))

                self.conn.commit()

                embed = discord.Embed(description=f"Order {order_id} successfully canceled.")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(description="Either the order does not exist or you are not the owner of the order.")
                await ctx.send(embed=embed)

        except sqlite3.Error as e:
            embed = discord.Embed(description=f"An error occurred while canceling the order: {e}")
            await ctx.send(embed=embed)

    @commands.command(name="cancel_all_orders_for_symbol", help="Cancel all orders for a specified symbol.")
    #    @is_allowed_user(930513222820331590, PBot)
    async def cancel_all_orders_for_symbol(self, ctx, symbol: str):
        try:
            cursor = self.conn.cursor()

            # Get all orders for the current user and specified symbol
            cursor.execute("""
                SELECT * FROM limit_orders
                WHERE user_id = ? AND symbol = ?
            """, (ctx.author.id, symbol))
            orders = cursor.fetchall()

            if orders:
                for order in orders:
                    target = get_p3_address(self.P3addrConn, order["user_id"])
                    if order["order_type"].lower() == "buy":
                        tax_percentage = self.calculate_tax_percentage(ctx, "buy_stock")
                        cost = order["quantity"] * order["price"]
                        fee = Decimal(cost) * Decimal(tax_percentage)
                        await self.send_from_reserve(ctx, ctx.author.id, (int(cost) - int(fee)))
                        print(f"""
                            Address: {target}
                            Refund: {cost:,}
                            Gas: {fee:,}
                        """)
                    else:
                        sender_addr = get_p3_address(self.P3addrConn, PBot)
                        await send_stock(self, ctx, target, sender_addr, order["symbol"], order["quantity"], False)
                        print(f"""
                            Address: {target}
                            Refund Stock: {order["symbol"]}
                            Amount: {order["quantity"]:,}
                        """)

                    # Perform the cancellation by deleting the order
                    cursor.execute("""
                        DELETE FROM limit_orders
                        WHERE order_id = ?
                    """, (order["order_id"],))

                self.conn.commit()

                embed = discord.Embed(description=f"All orders for symbol {symbol} successfully canceled.")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(description=f"No orders found for symbol {symbol} and the current user.")
                await ctx.send(embed=embed)

        except sqlite3.Error as e:
            embed = discord.Embed(description=f"An error occurred while canceling orders: {e}")
            await ctx.send(embed=embed)

    @commands.command(name="cancel_orders_for_symbol_price", help="Cancel orders for a specified symbol and price.")
    # @is_allowed_user(930513222820331590, PBot)
    async def cancel_orders_for_symbol_price(self, ctx, symbol: str, price: int = None):
        try:
            cursor = self.conn.cursor()

            # Get all orders for the current user, specified symbol, and optional price
            if price is not None:
                cursor.execute("""
                    SELECT * FROM limit_orders
                    WHERE user_id = ? AND symbol = ? AND price = ?
                """, (ctx.author.id, symbol, price))
            else:
                cursor.execute("""
                    SELECT * FROM limit_orders
                    WHERE user_id = ? AND symbol = ?
                """, (ctx.author.id, symbol))

            orders = cursor.fetchall()

            if orders:
                for order in orders:
                    target = get_p3_address(self.P3addrConn, order["user_id"])
                    if order["order_type"].lower() == "buy":
                        tax_percentage = self.calculate_tax_percentage(ctx, "buy_stock")
                        cost = order["quantity"] * order["price"]
                        fee = Decimal(cost) * Decimal(tax_percentage)
                        await self.send_from_reserve(ctx, ctx.author.id, (int(cost) - int(fee)))
                        print(f"""
                            Address: {target}
                            Refund: {cost:,}
                            Gas: {fee:,}
                        """)
                    else:
                        sender_addr = get_p3_address(self.P3addrConn, PBot)
                        await send_stock(self, ctx, target, sender_addr, order["symbol"], order["quantity"], False)
                        print(f"""
                            Address: {target}
                            Refund Stock: {order["symbol"]}
                            Amount: {order["quantity"]:,}
                        """)

                    # Perform the cancellation by deleting the order
                    cursor.execute("""
                        DELETE FROM limit_orders
                        WHERE order_id = ?
                    """, (order["order_id"],))

                self.conn.commit()

                embed = discord.Embed(description=f"All orders for symbol {symbol} and price {price} successfully canceled.")
                await ctx.send(embed=embed)
            else:
                embed = discord.Embed(description=f"No orders found for symbol {symbol}, price {price}, and the current user.")
                await ctx.send(embed=embed)

        except sqlite3.Error as e:
            embed = discord.Embed(description=f"An error occurred while canceling orders: {e}")
            await ctx.send(embed=embed)


    @commands.command(name="my_orders", help="Show your placed orders.")
    async def show_my_orders(self, ctx, symbol: str = None):
        try:
            cursor = self.conn.cursor()


            if symbol:
                # Fetch orders placed by the user
                cursor.execute("""
                    SELECT * FROM limit_orders
                    WHERE user_id = ? and symbol = ?
                    """, (ctx.author.id, symbol,))
                user_orders = cursor.fetchall()

            else:
                # Fetch orders placed by the user
                cursor.execute("""
                    SELECT * FROM limit_orders
                    WHERE user_id = ?
                    """, (ctx.author.id,))
                user_orders = cursor.fetchall()

            if not user_orders:
                embed = discord.Embed(description="You have no placed orders.")
                await ctx.send(embed=embed)
                return

            results_per_page = 5  # Adjust this based on how many results you want per page
            total_pages = (len(user_orders) + results_per_page - 1) // results_per_page

            for page_num in range(total_pages):
                start_index = page_num * results_per_page
                end_index = min((page_num + 1) * results_per_page, len(user_orders))

                embed = discord.Embed(title=f"Your Placed Orders - Page {page_num + 1}/{total_pages}", color=discord.Color.green())

                for index in range(start_index, end_index):
                    order = user_orders[index]

                    embed.add_field(name=f"Order ID: {order['order_id']}",
                                    value=f"Symbol: {order['symbol']}\nOrder Type: {order['order_type']}\nPrice: {order['price']}\nQuantity: {order['quantity']:,.0f}",
                                    inline=False)

                message = await ctx.send(embed=embed)

                if total_pages > 1:
                    if page_num > 0:
                        await message.add_reaction("⬅️")  # Previous page

                    if page_num < total_pages - 1:
                        await message.add_reaction("➡️")  # Next page

                def check(reaction, user):
                    return user == ctx.author and reaction.message.id == message.id

                try:
                    reaction, user = await self.bot.wait_for('reaction_add', timeout=60.0, check=check)

                    if str(reaction.emoji) == "⬅️" and page_num > 0:
                        page_num -= 1
                    elif str(reaction.emoji) == "➡️" and page_num < total_pages - 1:
                        page_num += 1

                    await message.clear_reactions()
                except asyncio.TimeoutError:
                    break

        except sqlite3.Error as e:
            embed = discord.Embed(description=f"An error occurred while fetching your orders: {e}")
            await ctx.send(embed=embed)

    @commands.command(name="grab_orders")
    @is_allowed_user(930513222820331590, PBot)
    async def grab_orders(self, ctx, stock_name: str, type: str):
        if type.lower() == "sell":
            result = await lowest_price_order(self, ctx, "sell", stock_name)
        elif type.lower() == "buy":
            result = await lowest_price_order(self, ctx, "buy", stock_name)

        if result:
            return result
        else:
            return False


    @commands.command(name="simulate_fill_orders")
    async def transact_order2(self, ctx, symbol, quantity_to_buy: int):
        if quantity_to_buy > 500_000_000_000_000_000_000_000:
            await ctx.send(f"Purchase quantity can't be over 500.000.000,000,000,000,000,000")
            return
        buyer_id = ctx.author.id
        buyer_addr = get_p3_address(self.P3addrConn, buyer_id)
        cursor = self.conn.cursor()

        # Retrieve stock information
        cursor.execute("SELECT * FROM stocks WHERE symbol=?", (symbol,))
        stock = cursor.fetchone()

        if stock is None:
            await ctx.send(f"{ctx.author.mention}, this stock does not exist.")
            return

        # Check the existing amount of this stock owned by the user
        cursor.execute("SELECT * FROM stocks WHERE symbol=?", (symbol,))
        stock = cursor.fetchone()
        result = await get_supply_stats(self, ctx, symbol)
        reserve, total_supply, locked, escrow, market, circulating = result
        cursor.execute("SELECT amount FROM user_stocks WHERE user_id=? AND symbol=?", (buyer_id, symbol))
        user_stock = cursor.fetchone()
        user_owned = int(user_stock[0]) if user_stock else 0
        user_escrow = await get_total_shares_user_order(self, buyer_id, symbol)

        if (user_owned + quantity_to_buy + user_escrow) > (total_supply * 0.18):
            embed = discord.Embed(description=f"{buyer_addr}, you cannot own more than 18%({(total_supply * 0.18):,.0f}) of the total supply of {symbol} stocks.\nAvailable: {escrow:,}\nTotal: {total_supply:,}\nYour Shares + Escrow: {user_owned:,} + {user_escrow:,}", color=discord.Color.red())
            await ctx.send(embed=embed)
            return

        current_timestamp = datetime.utcnow()


        is_staking_qse_genesis = self.is_staking_qse_genesis(buyer_id)


        market_price = await get_stock_price(self, ctx, symbol)
        color = discord.Color.green()
        embed = discord.Embed(title=f"Stock Transaction Processing", color=color)
        embed.add_field(name="Address:", value=f"{buyer_addr}", inline=False)
        embed.add_field(name="Stock:", value=f"{symbol}", inline=False)
        embed.add_field(name="Amount:", value=f"{quantity_to_buy:,.2f}", inline=False)
        lowest = await lowest_price_order(self, ctx, "sell", symbol)
        embed.add_field(name="Lowest Price:", value=f"{lowest['price']:,.2f}", inline=False)
        embed.add_field(name="Market Price:", value=f"{market_price:,.2f}", inline=False)
        current_balance = get_user_balance(self.conn, buyer_id)
        embed.add_field(name="Current Balance:", value=f"{current_balance:,.2f} $QSE", inline=False)

        embed.set_footer(text=f"Timestamp: {current_timestamp}")
        await ctx.send(embed=embed)

        # Fetch available sell orders
        sell_orders = await fetch_sell_orders(self, symbol)

        # Filter out orders owned by the buyer
        filtered_sell_orders = [order for order in sell_orders if order['user_id'] != buyer_id]

        # Early exit if no eligible sell orders
        if not filtered_sell_orders:
            embed = discord.Embed(
                title="No Available Sell Orders",
                description="There are no sell orders available from other users.",
                color=discord.Color.red()
            )
            await ctx.send(embed=embed)
            return

        # Iterate through sell orders
        orders_purchased = 0
        orders_removed = 0
        order_prices = []
        for order in filtered_sell_orders:  # Use the filtered list
            self.buy_timer_start = timeit.default_timer()
            order_id = order['order_id']
            seller_id = order['user_id']

            result = await get_supply_stats(self, ctx, symbol)
            reserve, total, locked, escrow, market, circulating = result
            price = order['price']
            supply_a = market
            if market == 0:
                supply_a = escrow


            order_prices.append(price)
            available_quantity = order['quantity']



            # Simulate buying logic (adjust according to your requirements)
            quantity_to_fill = min(quantity_to_buy, available_quantity)
            total_cost = price * quantity_to_fill
            tax_percentage = self.calculate_tax_percentage(ctx, "buy_stock")
            fee = total_cost * tax_percentage
            city = get_current_city(buyer_id)
            city_tax = await get_city_tax(self, ctx, city)
            c_tax = (Decimal(city_tax) * Decimal(total_cost))
            city_addr = await get_city_addr(self, ctx, city)
            await self.give_addr(ctx, city_addr, c_tax, False)
            total_cost_tax = Decimal(total_cost) + Decimal(fee) + Decimal(c_tax)


            seller_addr = get_p3_address(self.P3addrConn, seller_id)
            escrow_addr = get_p3_address(self.P3addrConn, PBot)


            # Check if the buyer has enough balance
            buyer_balance = get_user_balance(self.conn, buyer_id)
            seller_old = get_user_balance(self.conn, seller_id)
            if buyer_balance >= total_cost_tax:
                await self.give_addr(ctx, seller_addr, int(total_cost - fee), False)
#                add_city_tax(buyer_id, (fee / 2))
#                add_city_tax(seller_id, (fee / 2))

                await send_stock(self, ctx, buyer_addr, escrow_addr, symbol, quantity_to_fill, False)
                seller_new = get_user_balance(self.conn, seller_id)
                new_balance = get_user_balance(self.conn, buyer_id)
                await log_transaction(ledger_conn, ctx, "Buy Stock", symbol, quantity_to_fill, total_cost, total_cost_tax, current_balance, new_balance, price, "True")
                await log_order_transaction(ledger_conn, ctx, "Sell Stock", symbol, quantity_to_fill, total_cost, (total_cost - fee), seller_old, seller_new, price, "True", seller_id)
                mv = await get_etf_value(self, ctx, 6)
                await add_mv_metric(self, ctx, mv)
                await add_etf_metric(self, ctx)
#        await add_metal_metric(self, ctx)
                await add_reserve_metric(self, ctx)
                mv_avg = await calculate_average_mv(self)
                print(f"MV Avg: {mv_avg:,.2f}")
                total = sum(order_prices)
                average = total / len(order_prices)
                new_price  = await get_stock_price(self, ctx, symbol)



                await add_experience(self, self.conn, buyer_id, 1.5, ctx)
                await add_experience(self, self.conn, seller_id, 5, ctx)
                await autoliquidate(self, ctx)

                # Simulate updating order book
                if quantity_to_fill == available_quantity:
                    # Completely fill the order
                    remove_order(self.conn, order_id)
                    orders_removed += 1
                    print(f"Orders Removed: {orders_removed}\nQuantity to buy {quantity_to_fill:,.0f}")
                else:
                    # Partially fill the order
                    update_order_quantity(self.conn, order_id, available_quantity - quantity_to_fill)

                # Update remaining quantity to buy
                quantity_to_buy -= quantity_to_fill
                orders_purchased += 1

            # Check if all required quantity has been bought
            if quantity_to_buy <= 0:
                new_price = await get_stock_price(self, ctx, symbol)
                current_timestamp = datetime.utcnow()
                color = discord.Color.green()
                embed = discord.Embed(title=f"Stock Transaction Completed", color=color)
                embed.add_field(name="Address:", value=f"{buyer_addr}", inline=False)
                embed.add_field(name="Stock:", value=f"{symbol}", inline=False)
                total = sum(order_prices)
                average = total / len(order_prices)
                embed.add_field(name="Average Buy Price:", value=f"{average:,.2f}", inline=False)
                embed.add_field(name="Market Price:", value=f"{new_price:,.2f}({(((new_price - market_price) / market_price) * 100):,.5f}%)", inline=False)
                new_balance = get_user_balance(self.conn, buyer_id)
                embed.add_field(name="New Balance:", value=f"{new_balance:,.2f} $QSE", inline=False)
                embed.add_field(name="Orders Filled:", value=f"{orders_removed:,.0f}", inline=False)
                embed.add_field(name="Orders Purchased From:", value=f"{len(order_prices):,.0f}", inline=False)
                tax_rate = tax_percentage * 100
                embed.add_field(name="Gas Rate:", value=f"{tax_rate:.2f}%", inline=False)


                elapsed_time = timeit.default_timer() - self.buy_timer_start
                self.buy_stock_avg.append(elapsed_time)
                avg_time = sum(self.buy_stock_avg) / len(self.buy_stock_avg)
                embed.add_field(name="Transaction Time:", value=f"{elapsed_time:.2f} seconds", inline=False)
                embed.set_footer(text=f"Timestamp: {current_timestamp}")
                await ctx.send(embed=embed)
                break

    @commands.command(name="test_order")
    async def test_order(self, ctx, symbol, amount):
        sell_orders = await fetch_sell_orders(self, symbol)


        P3addrConn = sqlite3.connect("P3addr.db")

        for order in sell_orders:
            print(f"""
            {order['order_id']}
            {get_p3_address(P3addrConn, order['user_id'])}
            {order['price']}
            {order['quantity']}
            """)



    @commands.command(name="buy_stock", help="Buy stocks. Provide the stock name and amount.")
    @is_allowed_user(930513222820331590, PBot)
    async def buy_stock(self, ctx, stock_name: str, amount: int, stable_option: str = "False"):
        if amount == 0:
            await ctx.send(f"{ctx.author.mention}, you cannot buy 0 amount of {stock_name}.")
            return
        if amount <= 0:
            await ctx.send("Amount must be a positive number.")
            return


        price = await get_stock_price(self, ctx, stock_name)
        result = await get_supply_stats(self, ctx, stock_name)
        reserve, total, locked, escrow, market, circulating = result

        supply_a = market if market > 0 else escrow
        city = get_current_city(ctx.author.id)
        buy_price, sell_price = await get_city_prices_for_stock(self, ctx, stock_name, city)
        price = buy_price
        cost = Decimal(price) * Decimal(amount)
        tax_percentage = self.calculate_tax_percentage(ctx, "buy_stock")
        fee = cost * Decimal(tax_percentage)
        total_cost = cost + fee

        current_timestamp = datetime.utcnow()
        self.last_buyers = [entry for entry in self.last_buyers if (current_timestamp - entry[1]).total_seconds() <= self.calculate_average_time_type("buy_stock")]
        user_id = ctx.author.id
        P3addrConn = sqlite3.connect("P3addr.db")
        P3addr = get_p3_address(P3addrConn, user_id)
        sender_addr = get_p3_address(self.P3addrConn, PBot)
        seller_old = get_user_balance(self.conn, PBot)
        city = get_current_city(user_id)
        city_tax = await get_city_tax(self, ctx, city)
        c_tax = (Decimal(city_tax) * Decimal(cost))
        is_staking_qse_genesis = self.is_staking_qse_genesis(user_id)
        color = discord.Color.green()
        dPlace = "2"
        if stock_name.lower() == "roflstocks":
            dPlace = "8"
        embed = discord.Embed(title=f"Stock Transaction Processing", color=color)
        embed.add_field(name="Address:", value=f"{P3addr}", inline=False)
        embed.add_field(name="Stock:", value=f"{stock_name}", inline=False)
        embed.add_field(name="Quantity to Purchase:", value=f"{amount:,.0f}", inline=False)
        embed.add_field(name="Price:", value=f"{buy_price:,.{dPlace}f}", inline=False)
        embed.add_field(name="QSE to Pay:", value=f"{(Decimal(amount) * Decimal(buy_price)):,.2f}", inline=False)
        embed.add_field(name="Gas to Pay:", value=f"{(fee + c_tax):,.2f}", inline=False)
        embed.add_field(name="City Tax:", value=f"{(city_tax * 100):,.2f}%", inline=False)
        embed.set_footer(text=f"Timestamp: {current_timestamp}")

        await ctx.send(embed=embed)

        cursor = self.conn.cursor()
        buyer_id = ctx.author.id
        member = ctx.guild.get_member(user_id)


        result = await get_supply_stats(self, ctx, stock_name)
        reserve_owned, total_supply, locked, escrow, market, circulating = result

        cursor.execute("SELECT amount FROM user_stocks WHERE user_id=? AND symbol=?", (PBot, stock_name))
        reserve_stock = cursor.fetchone()
        reserve_owned = int(reserve_stock[0]) if reserve_stock else 0

        if amount > reserve_owned:
            await ctx.send(f"Purchase amount: {amount:,.0f} is more than Market Supply: {reserve_owned:,.0f}")
        # Retrieve stock information
        cursor.execute("SELECT * FROM stocks WHERE symbol=?", (stock_name,))
        stock = cursor.fetchone()
        available, price, total_supply = int(stock[4]), Decimal(stock[2]), int(stock[3])

        if stock is None:
            await ctx.send(f"{ctx.author.mention}, this stock does not exist.")
            return

        escrow_supply = escrow
        reserve_supply = reserve_owned


        # Check the existing amount of this stock owned by the user
        cursor.execute("SELECT amount FROM user_stocks WHERE user_id=? AND symbol=?", (ctx.author.id, stock_name))
        user_stock = cursor.fetchone()
        user_owned = int(user_stock[0]) if user_stock else 0

        if (user_owned + amount) > (total * 0.18):
            if stock_name.lower() == "p3:stable":
                pass
            else:
                embed = discord.Embed(description=f"{ctx.author.mention}, you cannot own more than 18%({(total * 0.18):,.0f}) of the total supply of {stock_name} stocks.\nAvailable: {reserve_supply:,}\nTotal: {total:,}\nYour Shares: {user_owned:,}", color=discord.Color.red())
                await ctx.send(embed=embed)
                return

        if amount > reserve_supply:
            await ctx.send(f"{ctx.author.mention}, there are only {reserve_supply:,} {stock_name} stocks available.")
            return



        current_balance = get_user_balance(self.conn, ctx.author.id)

        if total_cost > current_balance:
            missing_amount = total_cost - current_balance
            await ctx.send(f"{ctx.author.mention}, you do not have enough $QSE to buy these stocks. "
                           f"You need {missing_amount:,.2f} more $QSE, including Gas, to complete this purchase.")
            return

        new_balance = current_balance - total_cost
        P3addrConn = sqlite3.connect("P3addr.db")
        PBotAddr = get_p3_address(P3addrConn, PBot)
        print_transaction_buy_market(current_balance, new_balance, total_cost)
        c_tax = (Decimal(city_tax) * Decimal(cost))
        city_addr = await get_city_addr(self, ctx, city)
        await self.give_addr(ctx, PBotAddr, fee, False)
        await self.give_addr(ctx, city_addr, c_tax, False)
        await self.give_addr(ctx, PBotAddr, int(cost), False)
        P3addrConn = sqlite3.connect("P3addr.db")
        await send_stock(self, ctx, P3addr, sender_addr, stock_name, amount, False)


        print_stock_info(stock_name, locked, total, market, reserve, escrow)




        if amount == 0:
            print(f'Fix for 0 amount buy after order book')
        else:
            seller_new = get_user_balance(self.conn, PBot)


            new_price = await get_stock_price(self, ctx, stock_name)
            new_price, sell_price = await get_city_prices_for_stock(self, ctx, stock_name, city)
            if stock_name.lower() == "p3:stable":
                print(f"P3:Stable Minted: {amount:,.0f}")
                await self.mint_stock_stable(ctx, stock_name, (amount), False)
            await log_transaction(ledger_conn, ctx, "Buy Stock", stock_name, amount, cost, total_cost, current_balance, new_balance, buy_price, "True")
            await log_order_transaction(ledger_conn, ctx, "Sell Stock", stock_name, amount, total_cost, (cost), seller_old, seller_new, buy_price, "True", PBot)
            await log_transfer(self, ledger_conn, ctx, "P3 Bot", self.bot_address, get_user_id(self.P3addrConn, self.bot_address), int(fee) + c_tax)
            if stock_name in inverseStocks:
                                await self.mint_stock_supply(ctx, stock_name, round(amount * 4), False)

        current_timestamp = datetime.utcnow()
        color = discord.Color.green()
        embed = discord.Embed(title=f"Stock Transaction Completed", color=color)
        embed.add_field(name="Address:", value=f"{P3addr}", inline=False)
        embed.add_field(name="Stock:", value=f"{stock_name}", inline=False)
        embed.add_field(name="Quantity Purchased:", value=f"{amount:,.0f}", inline=False)

        embed.add_field(
            name="New Price:",
            value=f"{new_price:,.{dPlace}f} ({(((new_price - buy_price) / buy_price) * 100):,.5f}%)",
            inline=False
        )
        embed.add_field(name="Old Balance:", value=f"{current_balance:,.2f} $QSE", inline=False)
        embed.add_field(name="New Balance:", value=f"{new_balance:,.2f} $QSE", inline=False)
        tax_rate = tax_percentage * 100
        embed.add_field(name="Gas + City Tax:", value=f"{tax_rate:.2f}% + {(city_tax * 100):,.2f}%", inline=False)
        elapsed_time = timeit.default_timer() - self.buy_timer_start
        embed.add_field(name="Transaction Time:", value=f"{elapsed_time:.2f} seconds", inline=False)
        embed.set_footer(text=f"Timestamp: {current_timestamp}")

        await ctx.send(embed=embed)
        await add_experience(self, self.conn, ctx.author.id, 1, ctx)

        self.conn.commit()

        try:
            elapsed_time = timeit.default_timer() - self.buy_timer_start
            self.buy_stock_avg.append(elapsed_time)
            avg_time = sum(self.buy_stock_avg) / len(self.buy_stock_avg)
            print(f"""
                -------------------------------------
                Transaction Time: {elapsed_time:.2f}
                Average Transaction Time: {avg_time:.2f}
            """)
        except Exception as e:
            print(f"Timer error: {e}")


# Sell Stock
    @commands.command(name="sell_stock", help="Sell stocks. Provide the stock name and amount.")
    @is_allowed_user(930513222820331590, PBot)
    async def sell_stock(self, ctx, stock_name: str, amount: int):
        result = await get_supply_stats(self, ctx, stock_name)
        reserve, total, locked, escrow, market, circulating = result
        price = await get_stock_price(self, ctx, stock_name)


        current_timestamp = datetime.utcnow()
        self.last_sellers = [entry for entry in self.last_sellers if (current_timestamp - entry[1]).total_seconds() <= self.calculate_average_time_type("sell_stock")]
        user_id = ctx.author.id
        sender_addr = get_p3_address(self.P3addrConn, ctx.author.id)
        seller_old = get_user_balance(self.conn, PBot)
        P3addrConn = sqlite3.connect("P3addr.db")
        P3addr = get_p3_address(P3addrConn, user_id)
        supply_a = market if market > 0 else escrow
        city = get_current_city(ctx.author.id)
        buy_price, sell_price = await get_city_prices_for_stock(self, ctx, stock_name, city)
        price = sell_price
        city = get_current_city(user_id)
        city_tax = await get_city_tax(self, ctx, city)


        earnings = Decimal(price) * Decimal(amount)
        tax_percentage = self.calculate_tax_percentage(ctx, "sell_stock")  # Custom function to determine the tax percentage based on quantity and earnings
        fee = earnings * Decimal(tax_percentage)
        total_earnings = earnings - fee
        c_tax = (Decimal(city_tax) * Decimal(earnings))
        color = discord.Color.red()
        embed = discord.Embed(title=f"Stock Transaction Processing", color=color)
        embed.add_field(name="Address:", value=f"{P3addr}", inline=False)
        embed.add_field(name="Stock:", value=f"{stock_name}", inline=False)
        embed.add_field(name="Quantity to Sell:", value=f"{amount:,.0f}", inline=False)
        embed.add_field(name="Price:", value=f"{sell_price:,.2f}", inline=False)
        embed.add_field(name="QSE to recieve:", value=f"{(Decimal(amount) * Decimal(sell_price)):,.2f}", inline=False)
        embed.add_field(name="Gas to Pay:", value=f"{(fee + c_tax):,.2f}", inline=False)
        embed.add_field(name="City Tax:", value=f"{(city_tax * 100):,.2f}%", inline=False)
        embed.set_footer(text=f"Timestamp: {current_timestamp}")


        await ctx.send(embed=embed)

        stock_price = await get_stock_price(self, ctx, stock_name)

        member = ctx.guild.get_member(user_id)
        # Check if the user is already in a transaction
        # Call the check_impact function to handle impact calculation and confirmation
        cursor = self.conn.cursor()


        if self.check_last_action(self.last_sellers, user_id, current_timestamp):

            return
            # Add the current action to the list
        self.last_sellers.append((user_id, current_timestamp))
        result = "bugged"

        # Check the result and perform further actions if needed
        if result == "canceled":
            # Handle canceled transaction
            pass
        elif result == "ongoing_transaction":
            # Handle ongoing transaction
            pass
        else:


            if amount <= 0:
                await ctx.send("Amount must be a positive number.")
                return



            await ctx.message.delete()



            # Check if the user recently bought stocks
            cursor.execute("SELECT timestamp FROM user_daily_buys WHERE user_id=? AND symbol=? ORDER BY timestamp DESC LIMIT 1", (user_id, stock_name))
            last_buy_timestamp = cursor.fetchone()

            if last_buy_timestamp:
                last_buy_timestamp = datetime.strptime(last_buy_timestamp[0], "%Y-%m-%d %H:%M:%S")
                current_time = datetime.utcnow()
                time_difference = current_time - last_buy_timestamp

                if time_difference.total_seconds() < 1800:  # 1800 seconds = 30 minutes
                    remaining_time = timedelta(seconds=1800) - time_difference
                    if user_id != jacob:
                        await ctx.send(f"{ctx.author.mention}, you cannot sell {stock_name} stocks within {remaining_time}.")
                        return

            cursor.execute("SELECT amount FROM user_stocks WHERE user_id=? AND symbol=?", (user_id, stock_name))
            user_stock = cursor.fetchone()
            if not user_stock or int(user_stock[0]) < amount:
                await ctx.send(f"{ctx.author.mention}, you do not have enough {stock_name} stocks to sell.")
                return

            cursor.execute("SELECT * FROM stocks WHERE symbol=?", (stock_name,))
            stock = cursor.fetchone()
            if stock is None:
                await ctx.send(f"{ctx.author.mention}, this stock does not exist.")
                return

            current_balance = get_user_balance(self.conn, ctx.author.id)
            new_balance = current_balance + total_earnings
            user_id = ctx.author.id
            PBotAddr = get_p3_address(self.P3addrConn, PBot)
            c_tax = (Decimal(city_tax) * Decimal(earnings))
            city_addr = await get_city_addr(self, ctx, city)
            await self.give_addr(ctx, PBotAddr, fee, False)
            await self.give_addr(ctx, city_addr, c_tax, False)


            try:
                await self.send_from_reserve(ctx, user_id, int(total_earnings))
            except ValueError as e:
                await ctx.send(f"{ctx.author.mention}, an error occurred while updating the user balance. Error: {str(e)}")
                return



            # Proceed with the sell order if there's still remaining amount to sell
            if amount > 0:


                await send_stock(self, ctx, city_addr, sender_addr, stock_name, int(amount), False)
                print_stock_info(stock_name, locked, total, market, reserve, escrow)



                new_price = await get_stock_price(self, ctx, stock_name)
                buy_price, new_price = await get_city_prices_for_stock(self, ctx, stock_name, city)
                if stock_name.lower() == "p3:stable":
                    print(f"P3:Stable Burned: {amount:,.0f}")
                    await self.burn_stock_supply(ctx, stock_name, amount, False)

                seller_new = get_user_balance(self.conn, PBot)
                await log_transaction(ledger_conn, ctx, "Sell Stock", stock_name, amount, earnings, total_earnings, current_balance, new_balance, sell_price, "True")
                await log_order_transaction(ledger_conn, ctx, "Buy Stock", stock_name, amount, total_earnings, (earnings), seller_old, seller_new, sell_price, "True", PBot)
                await log_transfer(self, ledger_conn, ctx, "P3 Bot", self.bot_address, get_user_id(self.P3addrConn, self.bot_address), int(fee) + c_tax)

                self.conn.commit()
                user_id = ctx.author.id
                P3addrConn = sqlite3.connect("P3addr.db")
                P3addr = get_p3_address(P3addrConn, user_id)
                current_timestamp = datetime.utcnow()
                if stock_name.lower() != "p3:stable":
                    weighted_price = sell_price
                    weighted_price = await get_weighted_average_price(self, ctx, stock_name)
                    if weighted_price == None:
                        weighted_price = sell_price
                        print(weighted_price)
                    orders = []
                    city_id = await get_city_id(self, city)
                    if random.random() < 0.25:
                        weighted_price *= 2
                    if random.random() < 0.04:
                        weighted_price *= 4
                    orders.append((self, ctx, city_id, stock_name, "sell", round(weighted_price), amount))
                    await add_limit_orders(self, ctx, orders, False)


                color = discord.Color.red()
                embed = discord.Embed(title=f"Stock Transaction Completed", color=color)
                embed.add_field(name="Address:", value=f"{P3addr}", inline=False)
                embed.add_field(name="Stock:", value=f"{stock_name}", inline=False)
                embed.add_field(name="Quantity Sold:", value=f"{amount:,.0f}", inline=False)
                embed.add_field(
                    name="New Price:",
                    value=f"{new_price:,.2f} ({(((new_price - sell_price) / sell_price) * 100):,.5f}%)",
                    inline=False
                )
                embed.add_field(name="Old Balance:", value=f"{current_balance:,.2f} $QSE", inline=False)
                embed.add_field(name="New Balance:", value=f"{new_balance:,.2f} $QSE", inline=False)
                tax_rate = tax_percentage * 100
                embed.add_field(name="Gas + City Tax:", value=f"{tax_rate:.2f}% + {(city_tax * 100):,.2f}%", inline=False)
                elapsed_time = timeit.default_timer() - self.sell_timer_start
                embed.add_field(name="Transaction Time:", value=f"{elapsed_time:.2f} seconds", inline=False)
                embed.set_footer(text=f"Timestamp: {current_timestamp}")

                await ctx.send(embed=embed)
                await add_experience(self, self.conn, ctx.author.id, 5, ctx)

                self.sell_stock_avg.append(elapsed_time)
                avg_time = sum(self.sell_stock_avg) / len(self.sell_stock_avg)
                print(f"""
                -------------------------------------
                Transaction Time: {elapsed_time:.2f}
                Average Transaction Time: {avg_time:.2f}
                """)



    @commands.command(name='vacuum')
    @is_allowed_user(930513222820331590)
    async def vacuum_database(self, ctx):
        try:
            self.halt_trading = True
            embed = discord.Embed(description=f"Trading Halted for Database Vaccum", color=discord.Color.yellow())
            await ctx.send(embed=embed)
            embed = discord.Embed(description=f"Currency System Vaccum Started", color=discord.Color.yellow())
            await ctx.send(embed=embed)
            conn = sqlite3.connect("currency_system.db")
            conn.execute("VACUUM;")
            conn.close()
            embed = discord.Embed(description=f"Currency System Vaccum Succesful", color=discord.Color.green())
            await ctx.send(embed=embed)
            embed = discord.Embed(description=f"Address Database Vaccum Started", color=discord.Color.yellow())
            await ctx.send(embed=embed)
            conn = sqlite3.connect("P3addr.db")
            conn.execute("VACUUM;")
            conn.close()
            embed = discord.Embed(description=f"Address Database Vaccum Succesful", color=discord.Color.green())
            await ctx.send(embed=embed)
            embed = discord.Embed(description=f"Ledger Database Vaccum Started", color=discord.Color.yellow())
            await ctx.send(embed=embed)
            conn = sqlite3.connect("p3ledger.db")
            conn.execute("VACUUM;")
            conn.close()
            embed = discord.Embed(description=f"Ledger Database Vaccum Succesful", color=discord.Color.green())
            await ctx.send(embed=embed)
        except Exception as e:
            await ctx.send(f"An error occurred while vacuuming the database: {str(e)}")
        finally:
            self.halt_trading = False
            embed = discord.Embed(description=f"Trading Resumed, Database Vacuum Completed", color=discord.Color.green())
            await ctx.send(embed=embed)


    @commands.command(name="profit_loss_chart", aliases=["pl_chart"], help="Show profit/loss in a chart along with average buy/sell prices and bought/sold quantities.")
    async def profit_loss_chart(self, ctx, symbol):
        try:
            user_id = ctx.author.id
            # Fetch user's average stock prices
            avg_buy_price, avg_sell_price, total_avg_price = await get_average_stock_prices(self, ctx, user_id, symbol)

            # Fetch user's average quantity held
            avg_quantity_held_buy, avg_quantity_held_sell, combined_avg_quantity_held = await get_average_quantity_held(self, ctx, user_id, symbol)

            # Calculate profit/loss
            profit_loss = (avg_sell_price - avg_buy_price) * combined_avg_quantity_held

            # Calculate profit/loss ratio
            if avg_buy_price != 0:
                profit_loss_ratio = profit_loss / avg_buy_price
            else:
                profit_loss_ratio = 0

            # Create labels and values for the pie charts
            labels_buy_sell = ['Average Buy Price', 'Average Sell Price']
            values_buy_sell = [avg_buy_price, avg_sell_price]

            labels_bought_sold = ['Average Bought Quantity', 'Average Sold Quantity']
            values_bought_sold = [avg_quantity_held_buy, avg_quantity_held_sell]

            labels_profit_loss = ['Profit/Loss', 'Profit/Loss Ratio']
            values_profit_loss = [profit_loss, profit_loss_ratio]

            # Plotting the pie charts
            fig, axs = plt.subplots(3, 1, figsize=(8, 8))

            # Black background for each chart
            fig.patch.set_facecolor('black')

            # White labels for each pie chart
            label_color = 'white'

            # Chart for average buy/sell prices
            axs[0].pie(values_buy_sell, labels=labels_buy_sell, autopct='%1.1f%%', colors=['blue', 'green'], textprops={'color': label_color})
            axs[0].set_title(f"Average Buy/Sell Prices for {symbol}")

            # Chart for average bought/sold quantities
            axs[1].pie(values_bought_sold, labels=labels_bought_sold, autopct='%1.1f%%', colors=['purple', 'yellow'], textprops={'color': label_color})
            axs[1].set_title(f"Average Bought/Sold Quantities for {symbol}")

            # Chart for profit/loss
            axs[2].pie(values_profit_loss, labels=labels_profit_loss, autopct='%1.1f%%', colors=['green', 'red'], textprops={'color': label_color})
            axs[2].set_title(f"Profit/Loss for {symbol}")

            # Set number format to non-scientific notation
            for ax in axs:
                ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: '{:,.2f}'.format(x)))

            # Save the charts to a BytesIO object
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png')
            buffer.seek(0)

            # Send the charts as a Discord message
            file = discord.File(buffer, filename='pie_charts.png')
            await ctx.send(file=file)

        except sqlite3.Error as e:
            await ctx.send(f"An error occurred: {str(e)}")


    @commands.command(name="buy_sell_line_chart", aliases=["bs_line_chart"], help="Show line chart for all buys and sells of a specific symbol by a user.")
    async def buy_sell_line_chart(self, ctx, symbol):
        try:
            user_id = ctx.author.id

            # Connect to the database
            conn = sqlite3.connect("p3ledger.db", check_same_thread=False, isolation_level=None)
            cursor = conn.cursor()

            # Fetch all buy transactions for the symbol by the user
            cursor.execute("""
                SELECT timestamp, price, quantity
                FROM stock_transactions
                WHERE user_id = ? AND symbol = ? AND action = 'Buy Stock'
            """, (user_id, symbol))
            buy_transactions = cursor.fetchall()

            # Fetch all sell transactions for the symbol by the user
            cursor.execute("""
                SELECT timestamp, price, quantity
                FROM stock_transactions
                WHERE user_id = ? AND symbol = ? AND action = 'Sell Stock'
            """, (user_id, symbol))
            sell_transactions = cursor.fetchall()

            # Close database connection

            # Extract timestamps, prices, and quantities for buys and sells
            buy_timestamps, buy_prices, buy_quantities = zip(*buy_transactions) if buy_transactions else ([], [], [])
            sell_timestamps, sell_prices, sell_quantities = zip(*sell_transactions) if sell_transactions else ([], [], [])

            # Create the line chart
            fig, ax = plt.subplots(figsize=(10, 6))

            # Black background for the chart
            fig.patch.set_facecolor('black')
            ax.set_facecolor('black')  # Set axis background color

            # Set line colors
            buy_color = 'blue'
            sell_color = 'red'

            # Plot buy and sell transactions
            ax.plot(buy_timestamps, buy_prices, color=buy_color, marker='o', linestyle='-', label='Buy')
            ax.plot(sell_timestamps, sell_prices, color=sell_color, marker='o', linestyle='-', label='Sell')

            # Set title and labels
            ax.set_title(f"Buy and Sell Transactions for {symbol}", color='white')  # Set title color
            ax.set_xlabel("Timestamp", color='white')  # Set x-axis label color
            ax.set_ylabel("Price", color='white')  # Set y-axis label color
            ax.grid(True, color='grey')  # Set grid color

            # Set number format to non-scientific notation
            ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda x, _: '{:,.2f}'.format(x)))

            # Rotate x-axis labels for better readability
            plt.xticks(rotation=45, color='white')  # Set x-axis label color

            # Set tick colors
            ax.tick_params(axis='x', colors='white')  # Set x-axis tick color
            ax.tick_params(axis='y', colors='white')  # Set y-axis tick color

            # Add legend
            ax.legend()

            # Save the chart to a BytesIO object
            buffer = io.BytesIO()
            plt.savefig(buffer, format='png', facecolor='black')  # Set background color
            buffer.seek(0)

            # Send the chart as a Discord message
            file = discord.File(buffer, filename='line_chart.png')
            await ctx.send(file=file)

        except sqlite3.Error as e:
            await ctx.send(f"An error occurred: {str(e)}")

    @commands.command(name="get_circulating_supply", help="Get circulating supply of a stock excluding PBot.")
    async def get_circulating_supply(self, ctx, stock_symbol: str):
        cursor = self.conn.cursor()

        try:
            # Retrieve holdings of all users for the specified stock except for PBot's holdings
            cursor.execute("SELECT SUM(amount) FROM user_stocks WHERE symbol=? AND amount > 0 AND user_id != ?", (stock_symbol, PBot))
            circulating_supply = cursor.fetchone()[0]

            if circulating_supply is not None:
                return circulating_supply
            else:
                return 0

        except sqlite3.Error as e:
            await ctx.send(f"An error occurred while fetching circulating supply data: {str(e)}")



    @commands.command(name="my_stocks", help="Shows the user's stocks.")
    async def my_stocks(self, ctx, stock_name: str = None):
        async with self.db_semaphore:
            async with self.transaction_lock:
                user_id = ctx.author.id
                P3Addr = generate_crypto_address(ctx.author.id)
                await ctx.message.delete()
                await ctx.send(f"Loading Stock Portflio for {P3Addr}...")

                cursor = self.conn.cursor()

                cursor.execute("SELECT symbol, amount FROM user_stocks WHERE user_id=? AND amount > 0", (user_id,))
                user_stocks = cursor.fetchall()

                if not user_stocks:
                    await ctx.send(f"{ctx.author.mention}, you do not own any stocks.")
                    return





                if stock_name:
                    latest_price = await get_stock_price(self, ctx, stock_name)
                    # Display daily, weekly, and monthly average buy and sell prices for a specific stock
                    opening_price, current_price, interval_change = await get_stock_price_interval(self, ctx, stock_name, interval='daily')
                    avg_buy, avg_sell, avg_total = await get_average_stock_prices(self, ctx, user_id , stock_name)
                    avg_quantity_held_buy, avg_quantity_held_sell, average_hodl = await get_average_quantity_held(self, ctx, user_id, stock_name)
                    overall_pl = await get_stock_profit_loss(self, ctx, user_id, stock_name)

                    # Convert prices to strings and remove commas
                    opening_price_str = f"${opening_price:,.2f}" if opening_price is not None else "0.00 QSE"


                    embed = discord.Embed(
                        title=f"Stock Performance - {stock_name}",
                        description=f"Performance summary for {P3Addr}",
                        color=discord.Color.green()
                    )

                    embed.add_field(name="Current Price: ", value=f"${latest_price:,.2f}", inline=False)
                    # Include the amount owned for the specific stock
                    cursor.execute("SELECT amount FROM user_stocks WHERE user_id=? AND symbol=?", (user_id, stock_name))
                    amount_owned = cursor.fetchone()
                    if amount_owned:
                        result = await get_supply_stats(self, ctx, stock_name)
                        reserve, total, locked, escrow, market, circulating = result
                        hold_percentage = (amount_owned[0] / total) * 100
                        if hold_percentage < 0.1:
                            hold_decimal = 8
                        else:
                            hold_decimal = 2
                        embed.add_field(name="Amount Owned", value=f"{amount_owned[0]:,} ({hold_percentage:,.{hold_decimal}f}%)", inline=False)
                        embed.add_field(name="Value", value=f"{(amount_owned[0] * latest_price):,.2f}", inline=False)
                    embed.add_field(name="Daily Average Buy Price", value=opening_price_str, inline=False)
                    embed.add_field(name="Daily Average Sell Price", value=f"{current_price:,.2f} QSE", inline=False)

                    embed.add_field(name="Average Buy Price", value=f"{avg_buy:,.2f} QSE", inline=False)
                    embed.add_field(name="Average Sell Price", value=f"{avg_sell:,.2f} QSE", inline=False)
                    embed.add_field(name="Average Price", value=f"{avg_total:,.2f} QSE", inline=False)
                    embed.add_field(name="Average Holding", value=f"{average_hodl:,.0f} Shares", inline=False)
                    embed.add_field(name="Average Buy Holding", value=f"{avg_quantity_held_buy:,.0f} Shares", inline=False)
                    embed.add_field(name="Average Sells Holding", value=f"{avg_quantity_held_sell:,.0f} Shares", inline=False)
                    embed.add_field(name="Overall P/L", value=f"{overall_pl:,.2f} QSE", inline=False)


                    await ctx.send(embed=embed)
                    await self.profit_loss_chart(ctx, stock_name)
                    await self.buy_sell_line_chart(ctx, stock_name)
                    return



                page_size = 20  # Number of stocks to display per page
                total_pages = (len(user_stocks) + page_size - 1) // page_size

                embeds = []  # List to store the embeds

                for page in range(total_pages):
                    embed = discord.Embed(
                        title="My Stocks",
                        description=f"Stocks owned by {P3Addr} (Page {page + 1}/{total_pages}):",
                        color=discord.Color.green()
                    )

                    # Calculate the range of stocks for this page
                    start_idx = page * page_size
                    end_idx = (page + 1) * page_size


                    # Add stocks to the embed for this page
                    for stock in user_stocks[start_idx:end_idx]:
                        stock_symbol = stock['symbol']
                        amount_owned = stock['amount']
                        opening_price, current_price, interval_change = await get_stock_price_interval(self, ctx, stock_symbol, interval='daily')
                        avg_buy, avg_sell, avg_total = await get_average_stock_prices(self, ctx, user_id , stock_symbol)
                        avg_quantity_held_buy, avg_quantity_held_sell, average_hodl = await get_average_quantity_held(self, ctx, user_id, stock_symbol)
                        latest_price = await get_stock_price(self, ctx, stock_symbol)
                        overall_pl = await get_stock_profit_loss(self, ctx, user_id, stock_symbol)
                        share_value = amount_owned * latest_price


                        result = await get_supply_stats(self, ctx, stock_symbol)
                        reserve, total, locked, escrow, market, circulating = result
                        hold_percentage = (amount_owned / total) * 100
                        if hold_percentage < 0.1:
                            hold_decimal = 8
                        else:
                            hold_decimal = 2

                        # Convert opening_price to a string and remove commas
                        opening_price_str = f"{opening_price:,.2f} QSE" if opening_price is not None else "0.00 QSE"
                        if opening_price != None:
                            start_value = amount_owned * opening_price
                            current_value = amount_owned * latest_price
                            DPL = current_value - start_value
                        else:
                            DPL = 0
                        embed.add_field(
                            name=f"{stock_symbol} (Amount: {amount_owned:,} )",
                            value=f"* Current Price: {latest_price:,.2f} QSE\n* Holding Percentage: ({hold_percentage:,.{hold_decimal}f}%)\n* Average Buy Price: {avg_buy:,.2f}\n* Average Sell Price: {avg_sell:,.2f} QSE\n* Overall P/L {overall_pl:,.2f} QSE\n* Average Holding: {average_hodl:,.0f} Shares\n* Total Value: {share_value:,.2f} QSE",
                            inline=True
                        )

                    embeds.append(embed)

        # Send the first page
        current_page = 0
        message = await ctx.send(embed=embeds[current_page])

        # Add reactions for pagination
        if total_pages > 1:
            await message.add_reaction("⬅️")
            await message.add_reaction("➡️")

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ["⬅️", "➡️"]
            while True:
                try:
                    reaction, user = await self.bot.wait_for("reaction_add", timeout=120.0, check=check)
                except asyncio.TimeoutError:
                    break

                if str(reaction.emoji) == "➡️" and current_page < total_pages - 1:
                    current_page += 1
                    await message.edit(embed=embeds[current_page])
                elif str(reaction.emoji) == "⬅️" and current_page > 0:
                    current_page -= 1
                    await message.edit(embed=embeds[current_page])

        # Remove reactions after pagination or if there's only one page
        await message.clear_reactions()


    async def get_stock_info(self, ctx, stock):
        result = await lowest_price_order(self, ctx, "sell", stock[0])
        lowest_sell_price = result["price"] if result else None
        escrow_supply = await get_total_shares_in_orders(self, stock[0])
        reserve_supply = self.get_user_stock_amount(PBot, stock[0])
        reserve_supply = reserve_supply - escrow_supply
        result = await get_supply_stats(self, ctx, stock[0])
        current_price = await get_stock_price(self, ctx, stock[0])
        reserve, total, locked, escrow, market, circulating = result


        lowest_sell_price_formatted = f"{lowest_sell_price:,.2f}" if lowest_sell_price is not None else "N/A"

        stock_info = (
            f"{stock[0]}\n"
            f"Available: {market:,.0f}\n"
            f"Circulating: {circulating:,.0f}\n"
            f"Total Shares in Escrow: {escrow:,.0f}\n"
            f"Market Price: {current_price:,.2f}\n"
            f"Order Price: {lowest_sell_price_formatted} QSE"
        )
        return stock_info

    @commands.command(name='list_stocks', aliases=["stocks"])
    async def list_stocks(self, ctx):
        async with self.db_semaphore:
            async with self.transaction_lock:
                await ctx.message.delete()
                cursor = self.conn.cursor()
                cursor.execute("SELECT symbol, available, total_supply, price FROM stocks")
                stocks = cursor.fetchall()

        items_per_page = 10  # Number of stocks to display per page
        total_pages = (len(stocks) + items_per_page - 1) // items_per_page

        embed = discord.Embed(title="Quantum Stock Exchange", color=discord.Color.blue())
        embed.set_footer(text="Page 1 of {}".format(total_pages))

        page = 1
        start_index = (page - 1) * items_per_page
        end_index = start_index + items_per_page

        for stock in stocks[start_index:end_index]:

            avg_buy, avg_sell = await calculate_average_prices_by_symbol(self, stock[0])
            avg_price = (avg_buy + avg_sell) / 2
            current_price = await get_stock_price(self, ctx, stock[0])
#            await self.change_stock_price(ctx, stock[0], current_price)
            print(f"{stock[0]}: {current_price:,.2f}")

            stock_info = await self.get_stock_info(ctx, stock)
            embed.add_field(name="Stock:", value=stock_info, inline=False)

        message = await ctx.send(embed=embed)

        if total_pages > 1:
            await message.add_reaction("⬅️")
            await message.add_reaction("➡️")

            def check(reaction, user):
                return user == ctx.author and str(reaction.emoji) in ["⬅️", "➡️"]

            while True:
                try:
                    reaction, user = await self.bot.wait_for("reaction_add", timeout=120.0, check=check)
                except TimeoutError:
                    break

                if str(reaction.emoji) == "⬅️" and page > 1:
                    page -= 1
                elif str(reaction.emoji) == "➡️" and page < total_pages:
                    page += 1
                else:
                    continue

                start_index = (page - 1) * items_per_page
                end_index = start_index + items_per_page

                embed.clear_fields()

                for stock in stocks[start_index:end_index]:
                    avg_buy, avg_sell = await calculate_average_prices_by_symbol(self, stock[0])
                    avg_price = (avg_buy + avg_sell) / 2
                    current_price = await get_stock_price(self, ctx, stock[0])
#                    await self.change_stock_price(ctx, stock[0], current_price)
                    print(f"{stock[0]}: {current_price:,.2f}")
                    stock_info = await self.get_stock_info(ctx, stock)
                    embed.add_field(name="Stock:", value=stock_info, inline=False)

                embed.set_footer(text="Page {} of {}".format(page, total_pages))
                await message.edit(embed=embed)
                await message.remove_reaction(reaction, user)

        # Remove reactions at the end
        await message.clear_reactions()
